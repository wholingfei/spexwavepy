
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Examples &#8212; spexwavepy 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="User guide" href="userguide.html" />
    <link rel="prev" title="Getting started" href="getstart.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="userguide.html" title="User guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="getstart.html" title="Getting started"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">spexwavepy 1.0.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Examples</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h1>
<p>Apart from the sample codes shown for the <a class="reference internal" href="getstart.html#tutorial"><span class="std std-ref">tutorial</span></a>, we also provide several
examples in <strong>spexwavepy</strong> package to help users to learn how to do the data processing for
different speckle-based techniques. All the examples shown here are extracted from our previous
published research papers. We also shared the raw data for users of <strong>spexwavepy</strong> package.
Please refer to <a class="reference internal" href="getstart.html#rawdata"><span class="std std-ref">Getting started page</span></a> for downloading these raw data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>The shared raw data is only used for study. Please do not distribute the raw data.
If you would like to use these raw data for publication and so on,
please contact the authors of this package.</strong></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To be able to run all the provided examples with shared experiment data,
please change the default data folder path to where your data is stored once you
download it.</p>
</div>
<section id="plane-mirror-measurement-with-reference-beam">
<span id="expplane"></span><h2>Plane mirror measurement with reference beam<a class="headerlink" href="#plane-mirror-measurement-with-reference-beam" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please find the example code from <em>/spexwavepy/examples/planemirror_2D.py</em></p>
</div>
<p>In this example, we would like to show that how to use the
<a class="reference internal" href="principle.html#prinxssrefer"><span class="std std-ref">XSS technique with reference beam</span></a> to
measure a plane mirror.</p>
<p>This example basically extracts from <a class="reference internal" href="#huxssjsrpaper" id="id1"><span>[HuXSSJSRpaper]</span></a>.</p>
<p>After detemining the data folder path and appropriate ROI for both sample and
reference images, we define the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a>
classes to contain the data.
Then we define the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack_sam</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">sam_folder</span><span class="p">,</span> <span class="n">ROI_sam</span><span class="p">)</span>
<span class="n">imstack_ref</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">ref_folder</span><span class="p">,</span> <span class="n">ROI_ref</span><span class="p">)</span>
<span class="n">imstack_ref</span><span class="o">.</span><span class="n">flip</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>

<span class="n">track_XSS</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">imstack_sam</span><span class="p">,</span> <span class="n">imstack_ref</span><span class="p">)</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;2D&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">scandim</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">833.</span>     <span class="c1"># [mm]</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">scanstep</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># [um]</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">=</span> <span class="mf">1.07</span>  <span class="c1"># [um]</span>
</pre></div>
</div>
<p>Note that we set <code class="docutils literal notranslate"><span class="pre">flip</span></code> attribute to the reference image stack.
This is due to the fact that the reflected images after a mirror
flipped the incident beam. So, in order to be able to track the
shift of speckle patterns, we flip the reference images in the
reference image stack.</p>
<p>We only did x scan in this example, so the <code class="docutils literal notranslate"><span class="pre">scandim</span></code> of the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class is <em>‘x’</em>. We do
2D data analysis, the <code class="docutils literal notranslate"><span class="pre">dimension</span></code> is set to be <em>‘2D’</em>.</p>
<p>Before we do the speckle pattern tracking, another thing we need to
do is to align the speckle patterns from the two image stacks. It is
particularly needed when the test optic is a mirror.
We use <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.collimate" title="spexwavepy.trackfun.Tracking.collimate"><code class="xref py py-func docutils literal notranslate"><span class="pre">collimate()</span></code></a> function to do
the alignment. Please refer to the
<a class="reference internal" href="userguide.html#tracolli"><span class="std std-ref">User guide</span></a> for the detailed description of this function.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">track_XSS</span><span class="o">.</span><span class="n">collimate</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<p>After that, the speckle patterns from both image stacks are aligned and
ready to be tracked. We set the related parameters before we call the method
used for speckle tracking.
Please refer to the <a class="reference internal" href="userguide.html#traxss"><span class="std std-ref">User guide</span></a> for the detailed explanation of these
parameters.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">edge_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">edge_y</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">edge_z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="n">width</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">pad_xy</span> <span class="o">=</span> <span class="mi">30</span>
</pre></div>
</div>
<p>After setting the initial parameters,
we use either single-core version <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer" title="spexwavepy.trackfun.Tracking.XSS_withrefer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer()</span></code></a>
or multi-core version <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer_multi" title="spexwavepy.trackfun.Tracking.XSS_withrefer_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer_multi()</span></code></a>
of the method to obtain the speckle pattern shifts.
Since the scan direction is along ‘x’, then <code class="docutils literal notranslate"><span class="pre">edge_x</span></code> is 0.
Also, the <code class="docutils literal notranslate"><span class="pre">edge_z</span></code> is not symmetrical.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">track_XSS</span><span class="o">.</span><span class="n">XSS_withrefer</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">edge_z</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad_xy</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Or</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">track_XSS</span><span class="o">.</span><span class="n">XSS_withrefer_multi</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">edge_z</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad_xy</span><span class="p">,</span> <span class="n">cpu_no</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please check the available CPUs before calling <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer_multi" title="spexwavepy.trackfun.Tracking.XSS_withrefer_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer_multi()</span></code></a> method.</p>
</div>
<p>Note that we did <code class="docutils literal notranslate"><span class="pre">normalization</span></code> for the stiched images in this example.
The shift in <em>‘x’</em> direction looks like</p>
<a class="reference internal image-reference" href="_images/planeM_1.png"><img alt="_images/planeM_1.png" src="_images/planeM_1.png" style="width: 80%;" /></a>
<p>Since we only scanned in the horizontal (x) direction, the <code class="docutils literal notranslate"><span class="pre">delayX</span></code> is
the only “canonical” processed data
stored in the <code class="docutils literal notranslate"><span class="pre">track_XSS</span></code> class. No <code class="docutils literal notranslate"><span class="pre">track_XSS.delayY</span></code> is available.
However, we do store the tracked value in another direction in the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class.
In this example, the shift in <em>‘y’</em>  direction is stored in <code class="docutils literal notranslate"><span class="pre">track_XSS._delayY</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The underscored attribute such as <code class="docutils literal notranslate"><span class="pre">Tracking._delayX</span></code> or <code class="docutils literal notranslate"><span class="pre">Tracking._delayY</span></code> are not
intended to be exposed to the user. However, in some cases, they do help the users with
their data processing. Nonetheless, please keep in mind that the underscored data are not
“canonical” basically.</p>
</div>
<p>It looks like</p>
<a class="reference internal image-reference" href="_images/planeM_2.png"><img alt="_images/planeM_2.png" src="_images/planeM_2.png" style="width: 80%;" /></a>
<p>Since the tested mirror is an ultra-smooth plane mirror, the speckle shift in y
direction should be very small. If we extract a central horizontal line from the
2D map of Y shift, we can see a tilted straight line</p>
<a class="reference internal image-reference" href="_images/planeM_3.png"><img alt="_images/planeM_3.png" src="_images/planeM_3.png" style="width: 80%;" /></a>
<p>This indicate that the mirror is not perfectly parallel with the reference incident beam.
The raw images need to be rotated and carefully aligned. According to the paper <a class="reference internal" href="#huxssjsrpaper" id="id2"><span>[HuXSSJSRpaper]</span></a>,
the rotation angle is calculated to be around -0.275 degrees.</p>
<p>We can use <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.rotate" title="spexwavepy.imstackfun.Imagestack.rotate"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotate()</span></code></a> function
to do the rotation. See the <a class="reference internal" href="userguide.html#userot"><span class="std std-ref">User guide</span></a> for its help information.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">rotateang</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.275</span>       <span class="c1"># [degree]</span>
<span class="n">imstack_sam</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotateang</span><span class="p">)</span>
</pre></div>
</div>
<p>After the rotation, the edge of the raw images is non-physical. For example,
if we print out <code class="docutils literal notranslate"><span class="pre">imstack_sam.data</span></code>, we will see</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">imstack_sam</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="o">...</span><span class="p">,</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]],</span>

    <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="o">...</span><span class="p">,</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]],</span>

    <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="o">...</span><span class="p">,</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]],</span>

    <span class="o">...</span><span class="p">,</span>

    <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="o">...</span><span class="p">,</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]],</span>

    <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="o">...</span><span class="p">,</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]],</span>

    <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="o">...</span><span class="p">,</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]])</span>
</pre></div>
</div>
<p>As a result, we need to cut the edge of the rotated images.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">cut</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">imstack_sam</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">imstack_sam</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">cut</span><span class="p">:</span><span class="o">-</span><span class="n">cut</span><span class="p">,</span> <span class="n">cut</span><span class="p">:</span><span class="o">-</span><span class="n">cut</span><span class="p">]</span>
<span class="n">imstack_ref</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">imstack_ref</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">cut</span><span class="p">:</span><span class="o">-</span><span class="n">cut</span><span class="p">,</span> <span class="n">cut</span><span class="p">:</span><span class="o">-</span><span class="n">cut</span><span class="p">]</span>
</pre></div>
</div>
<p>After that, we redefine the <code class="docutils literal notranslate"><span class="pre">track_XSS</span></code> class and do the same operations
as before, using either single-core version <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer" title="spexwavepy.trackfun.Tracking.XSS_withrefer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer()</span></code></a>
or multi-core version <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer_multi" title="spexwavepy.trackfun.Tracking.XSS_withrefer_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer_multi()</span></code></a>
of the XSS tracking method, we have the following tracked shift in <em>y</em>
direction.</p>
<a class="reference internal image-reference" href="_images/PlaneM_5.png"><img alt="_images/PlaneM_5.png" src="_images/PlaneM_5.png" style="width: 80%;" /></a>
<p>We can also extract the central line</p>
<a class="reference internal image-reference" href="_images/PlaneM_6.png"><img alt="_images/PlaneM_6.png" src="_images/PlaneM_6.png" style="width: 80%;" /></a>
<p>We can see the tracked speckle pattern shift in <em>y</em> direction has been properly corrected.
We also have the tracked shift in <em>x</em> direction.</p>
<a class="reference internal image-reference" href="_images/PlaneM_4.png"><img alt="_images/PlaneM_4.png" src="_images/PlaneM_4.png" style="width: 80%;" /></a>
<p>Besides, the slope error in <em>x</em> direction has also been calculated and stored
in the <code class="docutils literal notranslate"><span class="pre">slopeX</span></code> of <code class="docutils literal notranslate"><span class="pre">track_XSS</span></code> class. Please refer to the
<a class="reference internal" href="principle.html#prinxssrefer"><span class="std std-ref">principle of the XSS technique with reference beam</span></a> and the
<a class="reference internal" href="userguide.html#slope"><span class="std std-ref">User guide</span></a> for reconstructing of the wavefront slope error.</p>
<div role="list" class="citation-list">
<div class="citation" id="huxssjsrpaper" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HuXSSJSRpaper<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>)</span>
<p>Hu, L., Wang, H., Fox, O., &amp; Sawhney, K. (2022).
Two-dimensional speckle technique for slope error measurements of
weakly focusing reflective X-ray optics.
J. Synchrotron Rad. 29(6).
<a class="reference external" href="https://doi.org/10.1107/S160057752200916X">https://doi.org/10.1107/S160057752200916X</a></p>
</div>
</div>
</section>
<section id="measurement-of-the-wavefront-local-curvature-after-a-plane-mirror">
<span id="exp2ndderiv"></span><h2>Measurement of the wavefront local curvature after a plane mirror<a class="headerlink" href="#measurement-of-the-wavefront-local-curvature-after-a-plane-mirror" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please find the example code from <em>/spexwavepy/examples/plane_XSSself.py</em></p>
</div>
<p>In this example, we will use the <a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a> to measure
the local curvature of the wavefront after a plane mirror. We will
show that <strong>the fine structures appeared on the intensity image correspond
to the local curvature map</strong>.
This example is extracted from <a class="reference internal" href="#hustripeoepaper" id="id3"><span>[HuStripeOEpaper]</span></a> and <a class="reference internal" href="#hustripeoepaper2" id="id4"><span>[HuStripeOEpaper2]</span></a>.
Please refer to the papers for the detailed physics of this example.</p>
<p>First, let’s set the parameters for the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class
<code class="docutils literal notranslate"><span class="pre">imstack</span></code> and the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class <code class="docutils literal notranslate"><span class="pre">track_XSS</span></code> as usual,</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">ROI</span> <span class="o">=</span> <span class="p">[</span><span class="mi">180</span><span class="p">,</span> <span class="mi">1980</span><span class="p">,</span> <span class="mi">690</span><span class="p">,</span> <span class="mi">1270</span><span class="p">]</span>   <span class="c1"># [y_start, y_end, x_start, x_end]</span>
<span class="n">imstack</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">folderName</span><span class="p">,</span> <span class="n">ROI</span><span class="p">)</span>
<span class="n">track_XSS</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">imstack</span><span class="p">)</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;2D&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">scandim</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1705.0</span>    <span class="c1">#[mm]</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">=</span> <span class="mf">3.0</span>    <span class="c1">#[um]</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">scanstep</span> <span class="o">=</span> <span class="mf">1.0</span>    <span class="c1">#[um]</span>
</pre></div>
</div>
<p>we call <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self" title="spexwavepy.trackfun.Tracking.XSS_self"><code class="xref py py-func docutils literal notranslate"><span class="pre">XSS_self()</span></code></a> or
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self_multi" title="spexwavepy.trackfun.Tracking.XSS_self_multi"><code class="xref py py-func docutils literal notranslate"><span class="pre">XSS_self_multi()</span></code></a> function
to process the data acquired using
<a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a>.
Please also refer to the <a class="reference internal" href="userguide.html#traxssself"><span class="std std-ref">User guide</span></a> for the detailed
explanation of the related parameters.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">edge_x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">edge_y</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">edge_z</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">nstep</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">width</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">pad_xy</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">normalize</span> <span class="o">=</span> <span class="kc">True</span>
<span class="c1">#track_XSS.XSS_self(edge_x, edge_y, edge_z, nstep, width, pad_xy, normalize, display=True)</span>
<span class="n">cpu_no</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">XSS_self_multi</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">edge_z</span><span class="p">,</span> <span class="n">nstep</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad_xy</span><span class="p">,</span> <span class="n">cpu_no</span><span class="p">,</span> <span class="n">normalize</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please check the available CPUs before calling <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self_multi" title="spexwavepy.trackfun.Tracking.XSS_self_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self_multi()</span></code></a> method.</p>
</div>
<p>For this technique, the wavefront local curvature is the quantity directly reconstructed.
The 2D map generated from the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self" title="spexwavepy.trackfun.Tracking.XSS_self"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self()</span></code></a> or
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self_multi" title="spexwavepy.trackfun.Tracking.XSS_self_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self_multi()</span></code></a> function
is the local curvature of the wavefront <strong>on the detector plane</strong>.
Since we san along the <em>x</em> direction, the 2D wavefront curvature is
stored in the <code class="docutils literal notranslate"><span class="pre">curvX</span></code> attribute of <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class.
Otherwise, the curvature in <em>y</em> direction is stroed in <code class="docutils literal notranslate"><span class="pre">curvY</span></code>.
The 2D figure of the wavefront local curvature in <em>x</em> direction is shown below.</p>
<a class="reference internal image-reference" href="_images/planeMXSSself.png"><img alt="_images/planeMXSSself.png" src="_images/planeMXSSself.png" style="width: 80%;" /></a>
<p>The far-field intensity images are also acquired. We read them and do the average.
The image stack data are stored in the <code class="docutils literal notranslate"><span class="pre">data</span></code> attribute of the
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class. We do the average on <code class="docutils literal notranslate"><span class="pre">data</span></code>.
Then we show the intensity image.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">imstack2</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">flatFolder</span><span class="p">,</span> <span class="n">ROI</span><span class="p">)</span>
<span class="n">imstack2</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
<span class="n">ffimage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">imstack2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/planeMInten.png"><img alt="_images/planeMInten.png" src="_images/planeMInten.png" style="width: 80%;" /></a>
<p>From the two images shown in the above, we can find that those structures in
the intensity image can be related to the structures appeared
in the wavefront local curvature 2D map.
The two papers <a class="reference internal" href="#hustripeoepaper" id="id5"><span>[HuStripeOEpaper]</span></a> and <a class="reference internal" href="#hustripeoepaper2" id="id6"><span>[HuStripeOEpaper2]</span></a> give a detailed
physical explanation of this phenomenon.</p>
<div role="list" class="citation-list">
<div class="citation" id="hustripeoepaper" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HuStripeOEpaper<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id3">1</a>,<a role="doc-backlink" href="#id5">2</a>)</span>
<p>Hu, L., Wang, H., Sutter, J., &amp; Sawhney, K. (2021).
Investigation of the stripe patterns from X-ray reflection optics.
Opt. Express 29, 4270-4286.
<a class="reference external" href="https://doi.org/10.1364/OE.417030">https://doi.org/10.1364/OE.417030</a></p>
</div>
<div class="citation" id="hustripeoepaper2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HuStripeOEpaper2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id6">2</a>)</span>
<p>Hu, L, Wang, H, Sutter, J. &amp;  Sawhney, K. (2023).
Research on the beam structures observed from X-ray optics in the far field.
Opt. Express 31(25):41000-41013.
<a class="reference external" href="https://doi.org/10.1364/OE.499685">https://doi.org/10.1364/OE.499685</a></p>
</div>
</div>
</section>
<section id="mirror-slope-error-curve-1d-reconstructed-from-the-dowmstream-setup">
<span id="iterative"></span><h2>Mirror slope error curve (1D) reconstructed from the dowmstream setup<a class="headerlink" href="#mirror-slope-error-curve-1d-reconstructed-from-the-dowmstream-setup" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please find the example code from <em>/spexwavepy/examples/curvm_XSSself.py</em></p>
</div>
<p>A curved mirror is measured in this example. The diffuser is placed
downstream of the mirror.</p>
<a class="reference internal image-reference" href="_images/curvMXSS_1.png"><img alt="_images/curvMXSS_1.png" src="_images/curvMXSS_1.png" style="width: 60%;" /></a>
<p>Because the curved mirror has no available reference beam, we use the
<a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a> for the measurement.
It is easy to obtain the 1D curve of the wavefront curvature.
This example is extracted from this paper <a class="reference internal" href="#zhoujsrpaper" id="id7"><span>[ZhouJSRpaper]</span></a>.
For the detailed description of the physics and algorithm, please refer to
the paper.</p>
<p>Let’s check the raw data image first.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">spexwavepy.corefun</span> <span class="kn">import</span> <span class="n">read_one</span>
<span class="n">ShowImage</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">im_sam</span> <span class="o">=</span> <span class="n">read_one</span><span class="p">(</span><span class="n">folderName</span> <span class="o">+</span> <span class="s1">&#39;ipp_292770_1.TIF&#39;</span><span class="p">,</span> <span class="n">ShowImage</span><span class="o">=</span><span class="n">ShowImage</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/curviter_1.png"><img alt="_images/curviter_1.png" src="_images/curviter_1.png" style="width: 80%;" /></a>
<p>To obtain the 1D wavefront local curvature curve,
we choose a small stripe of around 150 pixels in width,
that is around 1mm wide.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">ROI</span> <span class="o">=</span> <span class="p">[</span><span class="mi">338</span><span class="p">,</span> <span class="mi">643</span><span class="p">,</span> <span class="mi">675</span><span class="p">,</span> <span class="mi">825</span><span class="p">]</span>          <span class="c1">#[y_start, y_end, x_start, x_end]</span>

<span class="n">imstack</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">folderName</span><span class="p">,</span> <span class="n">ROI</span><span class="p">)</span>

<span class="n">track_XSS</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">imstack</span><span class="p">)</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;1D&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">scandim</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">mempos</span> <span class="o">=</span> <span class="s1">&#39;downstream&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1790.0</span>    <span class="c1">#[mm]</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">=</span> <span class="mf">6.45</span>    <span class="c1">#[um]</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">scanstep</span> <span class="o">=</span> <span class="mf">0.25</span>    <span class="c1">#[um]</span>

<span class="n">edge_x</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">edge_y</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">edge_z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="n">nstep</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">track_XSS</span><span class="o">.</span><span class="n">XSS_self</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">edge_z</span><span class="p">,</span> <span class="n">nstep</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>After setting up the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a>
class <code class="docutils literal notranslate"><span class="pre">imstack</span></code> and <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class
<code class="docutils literal notranslate"><span class="pre">track_XSS</span></code> and the related parameters,
we call <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self" title="spexwavepy.trackfun.Tracking.XSS_self"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self()</span></code></a> function to
calculate the wavefront local curvature <strong>on the detector plane</strong>.
The obtained result is stored in <code class="docutils literal notranslate"><span class="pre">track_XSS.curvY</span></code> attribute.</p>
<a class="reference internal image-reference" href="_images/curvmiter_2.png"><img alt="_images/curvmiter_2.png" src="_images/curvmiter_2.png" style="width: 80%;" /></a>
<p>In order to compare the at-wavelength measurement with the off-line NOM
measurement, we need to <strong>project the wavefront on the detector plane
back to the mirror surface</strong>. To do that,
we need the following iterative algorithm.
This algorithm has been described in detail in this paper <a class="reference internal" href="#zhoujsrpaper" id="id8"><span>[ZhouJSRpaper]</span></a>.
The main idea of the following iterative algorithm is also similar
to <a class="reference internal" href="#sebastiengrating" id="id9"><span>[SebastienGrating]</span></a>.</p>
<p>Two relations are used to devise the iterative algorithm.
First, the slope of the mirror can be calculated as</p>
<div class="math notranslate nohighlight">
\[slo = \frac{1}{2}\frac{Y_{det}-y}{d-x}\]</div>
<p>where <span class="math notranslate nohighlight">\(Y_{det}\)</span> is the detector coordinate, <span class="math notranslate nohighlight">\(d\)</span> is the
distance between the mirror and the detector plane. <span class="math notranslate nohighlight">\(x\)</span> and
<span class="math notranslate nohighlight">\(y\)</span> are the mirror coordinate.</p>
<p>Second, the slope of the mirror is also the half of the wavefront
slope. The wavefront slope can be calculated by the measured local
curvature. If we integrate the mirror slope, we can have the mirror
height, which is also <span class="math notranslate nohighlight">\(y\)</span> coordinate of the mirror.</p>
<div class="math notranslate nohighlight">
\[y = \int_{0}^{x}slo(x)dx\]</div>
<p>From the above equations, the mirror slope is the measured quantity and
is already known, the detector coordinate <span class="math notranslate nohighlight">\(Y_{det}\)</span> is also
known, so is the distance <span class="math notranslate nohighlight">\(d\)</span>.</p>
<p>We use the first equation to calculate the mirror surface corrdinate <span class="math notranslate nohighlight">\(x\)</span>,
the second equation to calculate <span class="math notranslate nohighlight">\(y\)</span>. We do it iteratively.
In the end, both <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> will converge.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="c1">######### Iterative algorithm for donwstream case</span>
<span class="n">iy</span> <span class="o">=</span> <span class="n">track_XSS</span><span class="o">.</span><span class="n">delayY</span>
<span class="n">loccurv_y</span> <span class="o">=</span> <span class="n">track_XSS</span><span class="o">.</span><span class="n">curvY</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">3.7e-3</span>                     <span class="c1">#[rad], pitch angle</span>
<span class="n">mirror_L</span> <span class="o">=</span> <span class="mf">0.10</span>                    <span class="c1">#[m], mirror length</span>
<span class="n">dist_mc2det</span> <span class="o">=</span> <span class="mf">2.925</span>                <span class="c1">#[m]</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">dist_mc2det</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">mirror_L</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>   <span class="c1">#[m]</span>
<span class="n">pixsize</span> <span class="o">=</span> <span class="n">track_XSS</span><span class="o">.</span><span class="n">pixsize</span>

<span class="n">loccurvs</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">loccurv_y</span><span class="p">)</span>
<span class="n">detPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">loccurvs</span><span class="p">))</span> <span class="o">*</span> <span class="n">pixsize</span> <span class="o">*</span> <span class="mf">1.e-6</span>     <span class="c1">#[m]</span>
<span class="n">SloErr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="n">loccurvs</span><span class="p">,</span> <span class="n">detPos</span><span class="p">)</span>           <span class="c1">#[rad]</span>
<span class="n">SloErr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">]),</span> <span class="n">SloErr</span><span class="p">))</span>                <span class="c1">#[rad]</span>
<span class="c1">#Inc_corr = np.linspace(-0.5*0.08*theta/41., 0.5*0.08*theta/41, len(SloErr))</span>
<span class="c1">#SloErr -= Inc_corr</span>
<span class="n">x_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mirror_L</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">SloErr</span><span class="p">))</span>                <span class="c1">#[m]</span>
<span class="n">y_init</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="n">SloErr</span><span class="o">*</span><span class="mf">0.</span><span class="o">+</span><span class="n">theta</span><span class="p">,</span> <span class="n">x_init</span><span class="p">)</span>             <span class="c1">#[m]</span>
<span class="n">y_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">]),</span> <span class="n">y_init</span><span class="p">))</span>          <span class="c1">#[m]</span>
<span class="n">Y_det</span> <span class="o">=</span> <span class="n">y_init</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">SloErr</span><span class="o">+</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span><span class="o">-</span><span class="n">x_init</span><span class="p">)</span>
<span class="n">Y_det</span> <span class="o">=</span> <span class="n">Y_det</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">detPos</span>
<span class="n">y_init2</span> <span class="o">=</span> <span class="n">Y_det</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">SloErr</span><span class="o">+</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span><span class="o">-</span><span class="n">x_init</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x_init</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">y_init</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">y_prev</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="p">(</span><span class="n">Y_det</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">SloErr</span> <span class="o">+</span> <span class="n">theta</span><span class="p">))</span>                   <span class="c1">#[m]</span>
    <span class="c1">#sys.exit(0)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">cumtrapz</span><span class="p">(</span><span class="n">SloErr</span><span class="o">+</span><span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                  <span class="c1">#[m]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">]),</span> <span class="n">y</span><span class="p">))</span>                        <span class="c1">#[m]</span>
    <span class="n">y_after</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">x_after</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1">#plt.plot(x*1.e3, s*1.e6)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration time: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y_prev</span><span class="o">-</span><span class="n">y_after</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x_prev</span><span class="o">-</span><span class="n">x_after</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
<span class="c1">#########</span>
</pre></div>
</div>
<p>After that, we fit the result with the elliptical mirror shape.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="c1">######### Fitting</span>
<span class="n">p</span> <span class="o">=</span> <span class="mf">46.</span>      <span class="c1">#[m]</span>
<span class="n">q</span> <span class="o">=</span> <span class="mf">0.4</span>      <span class="c1">#[m]</span>
<span class="n">theta</span> <span class="o">=</span> <span class="mf">3.e-3</span>     <span class="c1">#[rad]</span>
<span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">EllipseSlope</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">SloErr</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">([</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">theta</span><span class="o">-</span><span class="mf">0.3e-3</span><span class="p">],</span> <span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">theta</span><span class="o">+</span><span class="mf">0.3e-3</span><span class="p">]))</span>
<span class="n">SloFit</span> <span class="o">=</span> <span class="n">EllipseSlope</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">SloRes</span> <span class="o">=</span> <span class="n">SloErr</span> <span class="o">-</span> <span class="n">SloFit</span>
<span class="c1">#########</span>
</pre></div>
</div>
<p>We plot the measured on-line slope error and the off-line slope error
together.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="c1">######### Exel data reading</span>
<span class="kn">import</span> <span class="nn">pandas</span>

<span class="n">exel_folder</span> <span class="o">=</span> <span class="n">currentfolder</span> <span class="o">+</span> <span class="s2">&quot;/NOM_data.xlsx&quot;</span>
<span class="n">data_Fram</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="n">exel_folder</span><span class="p">)</span>
<span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_Fram</span><span class="p">)</span>
<span class="n">x_lane1</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">slo_lane1</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">sloErr_lane1</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">x_lane2</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">slo_lane2</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">sloErr_lane2</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">x_lane3</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">slo_lane3</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">sloErr_lane3</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">901</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="mf">1.e3</span><span class="o">-</span><span class="mi">41</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="o">-</span><span class="n">SloRes</span><span class="p">)</span><span class="o">*</span><span class="mf">1.e6</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;At-wavelength measurement&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_lane3</span><span class="p">,</span> <span class="n">sloErr_lane3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Off-line measurement&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Mirror length [mm]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Slope error [&#39;</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;$\mu$&#39;</span> <span class="o">+</span> <span class="s1">&#39;rad]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="c1">#########</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use the <a class="reference external" href="https://pandas.pydata.org/docs/index.html">pandas</a> library to
read the xlsx file. However, the pandas library is not mandatory for <strong>spexwavepy</strong>.
You can run <strong>spexwavepy</strong> well without the supoort of padans.</p>
</div>
<a class="reference internal image-reference" href="_images/curviter_3.png"><img alt="_images/curviter_3.png" src="_images/curviter_3.png" style="width: 80%;" /></a>
<p>We can also check the fitted parameters of the elliptical mirror.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">popt</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">4.57354460e+01</span> <span class="mf">3.70107898e-01</span> <span class="mf">3.07919456e-03</span><span class="p">]</span>
</pre></div>
</div>
<p>The fitted p is 45.735 m, q is 0.37 m, <span class="math notranslate nohighlight">\(\theta\)</span>
is 3.08 mrad.
The initial value <code class="docutils literal notranslate"><span class="pre">theta</span></code>, <code class="docutils literal notranslate"><span class="pre">D</span></code> can be finely adjusted
to match the off-line NOM data.</p>
<div role="list" class="citation-list">
<div class="citation" id="zhoujsrpaper" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ZhouJSRpaper<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id7">1</a>,<a role="doc-backlink" href="#id8">2</a>)</span>
<p>Zhou T., Hu L., Wang, H., Sutter, J. &amp;  Sawhney, K. (2024).
At-wavelength metrology of an X-ray mirror using a downstream wavefront modulator.
J. Synchrotron Radiat. 31(3) (To be published)</p>
</div>
<div class="citation" id="sebastiengrating" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">SebastienGrating</a><span class="fn-bracket">]</span></span>
<p>S. Berujon, and E. Ziegler,
Grating-based at-wavelength metrology of hard x-ray reflective optics
Opt. Lett. 37, 4464-4466 (2012).
<a class="reference external" href="https://doi.org/10.1364/OL.37.004464">https://doi.org/10.1364/OL.37.004464</a></p>
</div>
</div>
</section>
<section id="comparison-between-self-reference-xss-technique-and-self-reference-xst-technique">
<span id="expxssvsxst"></span><h2>Comparison between self-reference XSS technique and self-reference XST technique<a class="headerlink" href="#comparison-between-self-reference-xss-technique-and-self-reference-xst-technique" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please find the example code from <em>/spexwavepy/examples/XSTselfvsXSSself.py</em></p>
</div>
<p>In this example, we will compare the <strong>1D</strong>
<a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a>
and the <strong>1D</strong> <a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a> at first.
The optic we used is a plane mirror. Similar results has been published
in <a class="reference internal" href="#huxstoepaperfast" id="id10"><span>[HuXSTOEPaperFast]</span></a>.</p>
<p>The plane mirror speckle data is the same as in the example of
<a class="reference internal" href="#expplane"><span class="std std-ref">plane mirror measurement with reference beam</span></a>, and we only use the
data with mirror in the beam.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">ROI</span> <span class="o">=</span> <span class="p">[</span><span class="mi">600</span><span class="p">,</span> <span class="mi">1600</span><span class="p">,</span> <span class="mi">740</span><span class="p">,</span> <span class="mi">2040</span><span class="p">]</span>
</pre></div>
</div>
<p>A width of around 1mm is chosen for the 1D data analysis,
shown as a red rectangular box in the following figure.
The mirror length is along the horizontal direction,
the width is along the vertical direction.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/XSTvsXSS_1.png"><img alt="_images/XSTvsXSS_1.png" src="_images/XSTvsXSS_1.png" style="width: 60%;" /></a>
</figure>
<p>Next let’s use the self-reference XSS technique.
Similar to the above examples, we define the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a>
class <code class="docutils literal notranslate"><span class="pre">imstack</span></code>, the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class <code class="docutils literal notranslate"><span class="pre">track_XSS</span></code>
and their related parameters in order.
Then we call the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self" title="spexwavepy.trackfun.Tracking.XSS_self"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self()</span></code></a> function.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">sam_folderX</span><span class="p">,</span> <span class="n">ROI</span><span class="p">)</span>

<span class="n">track_XSS</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">imstack</span><span class="p">)</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;1D&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">scandim</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">833.</span>   <span class="c1"># [mm]</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">scanstep</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># [um]</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">=</span> <span class="mf">1.07</span>  <span class="c1"># [um]</span>

<span class="n">edge_x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">edge_y</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">edge_z</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">nstep</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">track_XSS</span><span class="o">.</span><span class="n">XSS_self</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">edge_z</span><span class="p">,</span> <span class="n">nstep</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Unlike the example of <a class="reference internal" href="#expplane"><span class="std std-ref">plane mirror measurement with reference beam</span></a>,
in which the <a class="reference internal" href="principle.html#prinxssrefer"><span class="std std-ref">XSS technique with reference beam</span></a> is used,
we use the <a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a> in this example.
Thus, the local wavefront curvature other than local wavefront slope is obtained directly
from the data processing procedure.
Since the speckle generator was scanned in the horizontal direction,
the obtained wavefront local curvature is stored in the <code class="docutils literal notranslate"><span class="pre">curv_X</span></code> attribute of
<code class="docutils literal notranslate"><span class="pre">track_XSS</span></code> class.</p>
<p>We know that the wavefront local curvatur can also be obrained using the
<a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>.
Doing the same as in the above, we create a new
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class <code class="docutils literal notranslate"><span class="pre">track_XST</span></code>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack_1</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">data_folder</span><span class="p">,</span> <span class="n">ROI</span><span class="p">)</span>
<span class="n">imstack_1</span><span class="o">.</span><span class="n">fnum</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">imstack_1</span><span class="o">.</span><span class="n">fstart</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">imstack_2</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">data_folder</span><span class="p">,</span> <span class="n">ROI</span><span class="p">)</span>
<span class="n">imstack_2</span><span class="o">.</span><span class="n">fnum</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">imstack_2</span><span class="o">.</span><span class="n">fstart</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">track_XST</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">imstack_1</span><span class="p">,</span> <span class="n">imstack_2</span><span class="p">)</span>
<span class="n">track_XST</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;1D&#39;</span>
<span class="n">track_XST</span><span class="o">.</span><span class="n">scandim</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
<span class="n">track_XST</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">833.</span>   <span class="c1"># [mm]</span>
<span class="n">track_XST</span><span class="o">.</span><span class="n">scanstep</span> <span class="o">=</span> <span class="mf">5.0</span>  <span class="c1"># [um]</span>
<span class="n">track_XST</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">=</span> <span class="mf">1.07</span>  <span class="c1"># [um]</span>
</pre></div>
</div>
<p>Two images taken at two different diffuser positions are only needed for the
<a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>, we can choose any two images
form the scanned dataset. We choose the first (No. 0) image and the sixth (No. 5) image.
Thus, the <code class="docutils literal notranslate"><span class="pre">scanstep</span></code> is 5 <span class="math notranslate nohighlight">\(\mu m\)</span>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">edge_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="n">edge_y</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">pad_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="n">hw_xy</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">pad_y</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">track_XST</span><span class="o">.</span><span class="n">XST_self</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">,</span> <span class="n">hw_xy</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>To use the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self" title="spexwavepy.trackfun.Tracking.XST_self"><code class="xref py py-func docutils literal notranslate"><span class="pre">XST_self()</span></code></a> function to process the data,
we need to set some additional parameters properly.
Please refer to the <a class="reference internal" href="userguide.html#traxstself"><span class="std std-ref">user guide</span></a> for the meaning of these parameters.
The obtained wavefront local curvature is also stored in the <code class="docutils literal notranslate"><span class="pre">curvX</span></code> or <code class="docutils literal notranslate"><span class="pre">curvY</span></code> attribute.
In this case, it is in <code class="docutils literal notranslate"><span class="pre">curvX</span></code>.</p>
<p>We plot the wavefront curvature obtained from the two technqiues together, note that the way
to calculate the wavefront curvature from the two techniques are different, please refer to
<a class="reference internal" href="userguide.html#curvature"><span class="std std-ref">Local curvature reconstruction</span></a>.</p>
<figure class="align-default" id="id13">
<a class="reference internal image-reference" href="_images/XSTvsXSS_2.png"><img alt="_images/XSTvsXSS_2.png" src="_images/XSTvsXSS_2.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Wavefront curvature obtained from XSS and XST techniques.</span><a class="headerlink" href="#id13" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The results from the two techniques match with each other. Further, we can also
plot the tracking coefficient. The tracking coefficient is stored in
<code class="docutils literal notranslate"><span class="pre">resX</span></code> and/or <code class="docutils literal notranslate"><span class="pre">resY</span></code> attribute of <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a>
class.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/XSTvsXSS_3.png"><img alt="_images/XSTvsXSS_3.png" src="_images/XSTvsXSS_3.png" style="width: 80%;" /></a>
</figure>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/XSTvsXSS_4.png"><img alt="_images/XSTvsXSS_4.png" src="_images/XSTvsXSS_4.png" style="width: 80%;" /></a>
</figure>
<p>From the tracking coefficients we can find that <strong>the XSS technique in general have
higher tracking coefficient than the conventional XST technique</strong>.</p>
<p>We can also compare the <strong>2D</strong> data prcossing method of these two techniques.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">track_XSS</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;2D&#39;</span> <span class="c1">#&#39;1D&#39;</span>

<span class="n">edge_x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">edge_y</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">edge_z</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">nstep</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pad_xy</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">hw_xy</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">cpu_no</span> <span class="o">=</span> <span class="mi">16</span>
<span class="c1">#track_XSS.XSS_self(edge_x, edge_y, edge_z, nstep, hw_xy, pad_xy, display=True, normalize=True)</span>
<span class="n">track_XSS</span><span class="o">.</span><span class="n">XSS_self_multi</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">edge_z</span><span class="p">,</span> <span class="n">nstep</span><span class="p">,</span> <span class="n">hw_xy</span><span class="p">,</span> <span class="n">pad_xy</span><span class="p">,</span> <span class="n">cpu_no</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please check the available CPUs before calling
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self_multi" title="spexwavepy.trackfun.Tracking.XSS_self_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self_multi()</span></code></a> method.</p>
</div>
<p>For 2D case of <a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a>,
the original parameters for 1D technique remain the same.
Several new parameters need to be added for the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self" title="spexwavepy.trackfun.Tracking.XSS_self"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self()</span></code></a> or
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self_multi" title="spexwavepy.trackfun.Tracking.XSS_self_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self_multi()</span></code></a> function.
Please refer to the <a class="reference internal" href="userguide.html#traxss"><span class="std std-ref">user guide</span></a> for the setting of these parameters.
We have the following result of 2D local wavefront curvature map.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/XSSvsXST2D_1.png"><img alt="_images/XSSvsXST2D_1.png" src="_images/XSSvsXST2D_1.png" style="width: 80%;" /></a>
</figure>
<p>Likewise, we can do the 2D data processing for <a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>.
Also, the parameters for 2D processing should be changed in order to have successful tracking result.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">track_XST</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;2D&#39;</span> <span class="c1">#&#39;1D&#39;</span>

<span class="n">edge_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="n">edge_y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
<span class="n">pad_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="n">hw_xy</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">pad_y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
<span class="n">window</span> <span class="o">=</span> <span class="mi">60</span>
<span class="n">cpu_no</span> <span class="o">=</span> <span class="mi">16</span>

<span class="c1">#track_XST.XST_self(edge_x, edge_y, pad_x, pad_y, hw_xy, window, display=True, normalize=True)</span>
<span class="n">track_XST</span><span class="o">.</span><span class="n">XST_self_multi</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">,</span> <span class="n">hw_xy</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">cpu_no</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please check the available CPUs before calling
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self_multi" title="spexwavepy.trackfun.Tracking.XST_self_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XST_self_multi()</span></code></a> method.</p>
</div>
<p>Note that sometimes the following warning information will pop out,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Potential</span> <span class="n">tracking</span> <span class="n">failure</span><span class="p">,</span> <span class="n">no</span> <span class="n">subpixel</span> <span class="n">registration</span><span class="p">:</span>
</pre></div>
</div>
<p>This is because some subregion changed too much that the tracking fails. Ignore those warnings,
we still have the following 2D wavefront map.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/XSSvsXST2D_2.png"><img alt="_images/XSSvsXST2D_2.png" src="_images/XSSvsXST2D_2.png" style="width: 80%;" /></a>
</figure>
<p>The wavefront curvature map from the <a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>
has lower spatial resolution
and accuracy compared to the <a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a>.</p>
<div role="list" class="citation-list">
<div class="citation" id="huxstoepaperfast" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HuXSTOEPaperFast<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id10">1</a>,<a role="doc-backlink" href="#id11">2</a>,<a role="doc-backlink" href="#id12">3</a>)</span>
<p>Hu, L., Wang, H., Fox, O., &amp; Sawhney, K. (2022).
Fast wavefront sensing for X-ray optics with an alternating speckle tracking technique.
Opt. Exp., 30(18), 33259-33273.
<a class="reference external" href="https://doi.org/10.1364/OE.460163">https://doi.org/10.1364/OE.460163</a></p>
</div>
</div>
</section>
<section id="kb-mirror-alignment-using-self-reference-xst-technique">
<span id="expkbalign"></span><h2>KB mirror alignment using self-reference XST technique<a class="headerlink" href="#kb-mirror-alignment-using-self-reference-xst-technique" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please find the example code from <em>/spexwavepy/examples/KBalignment.py</em></p>
</div>
<p>In this example we will show how to align KB mirror’s pitch angle (<span class="math notranslate nohighlight">\(\theta\)</span>)
using the <a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>. This example is similar
to Fig.5 in <a class="reference internal" href="#huxstoepaperfast" id="id11"><span>[HuXSTOEPaperFast]</span></a>.</p>
<p>The basic idea is also described in the above paper. At the nominal angle <span class="math notranslate nohighlight">\(\theta\)</span>,
the local curvature is constant along the mirror length. However, if it deviates to the
nominal value, the local curvature will change along the mirror length. The change of the
local curvature can be assumed linealy to the mirror length coordinate.</p>
<p>We first obtain the wavefront curvature for both HKB and VKB using the
<a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>.
Note that for this technique, only one image is needed for each image stack,
thus, the parameter <code class="docutils literal notranslate"><span class="pre">fnum</span></code> is 1. In each folder, the two images are at two different
diffuser positions. The movement of the diffuser is 4 <span class="math notranslate nohighlight">\(\mu m\)</span>.
The codes in this example for calling the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self" title="spexwavepy.trackfun.Tracking.XST_self"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XST_self()</span></code></a>
function is similar to the above example.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="c1">###### HKB self-reference XST</span>
<span class="n">ROI_HKB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">545</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">330</span><span class="p">]</span>

<span class="n">delayHKB_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">13</span><span class="p">,</span> <span class="mi">466</span><span class="p">))</span>
<span class="n">curvYHKB_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">13</span><span class="p">,</span> <span class="mi">466</span><span class="p">))</span>

<span class="k">for</span> <span class="n">jc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">imstack_tmp_1</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">folder_prefix_HKB</span><span class="o">+</span><span class="s1">&#39;theta&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">jc</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">ROI_HKB</span><span class="p">)</span>
    <span class="n">imstack_tmp_1</span><span class="o">.</span><span class="n">fstart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">imstack_tmp_1</span><span class="o">.</span><span class="n">fnum</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">imstack_tmp_2</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">folder_prefix_HKB</span><span class="o">+</span><span class="s1">&#39;theta&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">jc</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">ROI_HKB</span><span class="p">)</span>
    <span class="n">imstack_tmp_2</span><span class="o">.</span><span class="n">fstart</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">imstack_tmp_2</span><span class="o">.</span><span class="n">fnum</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">track_tmp</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">imstack_tmp_1</span><span class="p">,</span> <span class="n">imstack_tmp_2</span><span class="p">)</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;1D&#39;</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">scandim</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1650.0</span>   <span class="c1"># [mm]</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">scanstep</span> <span class="o">=</span> <span class="mf">4.0</span>   <span class="c1"># [um]</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">=</span> <span class="mf">6.45</span>   <span class="c1"># [um]</span>

    <span class="n">edge_x</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">edge_y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
    <span class="n">pad_x</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">pad_y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
    <span class="n">hw_xy</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="n">track_tmp</span><span class="o">.</span><span class="n">XST_self</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">,</span> <span class="n">hw_xy</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">delayHKB_stack</span><span class="p">[</span><span class="n">jc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">track_tmp</span><span class="o">.</span><span class="n">delayY</span>
    <span class="n">curvYHKB_stack</span><span class="p">[</span><span class="n">jc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">track_tmp</span><span class="o">.</span><span class="n">curvY</span>

<span class="c1">##### VKB self-reference XST</span>
<span class="n">ROI_HKB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">350</span><span class="p">]</span>

<span class="n">delayVKB_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">13</span><span class="p">,</span> <span class="mi">286</span><span class="p">))</span>
<span class="n">curvYVKB_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">13</span><span class="p">,</span> <span class="mi">286</span><span class="p">))</span>

<span class="k">for</span> <span class="n">jc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">imstack_tmp_1</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">folder_prefix_HKB</span><span class="o">+</span><span class="s1">&#39;theta&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">jc</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">ROI_HKB</span><span class="p">)</span>
    <span class="n">imstack_tmp_1</span><span class="o">.</span><span class="n">fstart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">imstack_tmp_1</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">imstack_tmp_2</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">folder_prefix_HKB</span><span class="o">+</span><span class="s1">&#39;theta&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">jc</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">ROI_HKB</span><span class="p">)</span>
    <span class="n">imstack_tmp_2</span><span class="o">.</span><span class="n">fstart</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">imstack_tmp_2</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">track_tmp</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">imstack_tmp_1</span><span class="p">,</span> <span class="n">imstack_tmp_2</span><span class="p">)</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="s1">&#39;1D&#39;</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">scandim</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1650.0</span>   <span class="c1"># [mm]</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">scanstep</span> <span class="o">=</span> <span class="mf">4.0</span>   <span class="c1"># [um]</span>
    <span class="n">track_tmp</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">=</span> <span class="mf">6.45</span>   <span class="c1"># [um]</span>

    <span class="n">edge_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">edge_y</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">pad_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">pad_y</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">hw_xy</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="n">track_tmp</span><span class="o">.</span><span class="n">XST_self</span><span class="p">(</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span> <span class="n">pad_x</span><span class="p">,</span> <span class="n">pad_y</span><span class="p">,</span> <span class="n">hw_xy</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">delayVKB_stack</span><span class="p">[</span><span class="n">jc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">track_tmp</span><span class="o">.</span><span class="n">delayX</span>
    <span class="n">curvYVKB_stack</span><span class="p">[</span><span class="n">jc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">track_tmp</span><span class="o">.</span><span class="n">curvX</span>
</pre></div>
</div>
<p>We then plot the obtained local curvature, which is stored in the <code class="docutils literal notranslate"><span class="pre">curvX</span></code> and <code class="docutils literal notranslate"><span class="pre">curvY</span></code> in the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class, for both HKB and VKB.</p>
<figure class="align-default" id="id14">
<a class="reference internal image-reference" href="_images/HKB_1.png"><img alt="_images/HKB_1.png" src="_images/HKB_1.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Local wavefront curvature of HKB mirror.</span><a class="headerlink" href="#id14" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can find that the data close to one end is abnormal due to the visible
stains observed on the mirror surface, we cut that part.</p>
<figure class="align-default" id="id15">
<a class="reference internal image-reference" href="_images/HKB_2.png"><img alt="_images/HKB_2.png" src="_images/HKB_2.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Local wavefront curvature of HKB mirror after cropping the abnormal data.</span><a class="headerlink" href="#id15" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We do the same for the VKB mirror.</p>
<figure class="align-default" id="id16">
<a class="reference internal image-reference" href="_images/VKB_1.png"><img alt="_images/VKB_1.png" src="_images/VKB_1.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Local wavefront curvature of VKB mirror.</span><a class="headerlink" href="#id16" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We then do the linear fitting for the measured local wavefront curvature data.
From the following figure we can see the linear relation
predicted by the theory clearly. The nominal angle <span class="math notranslate nohighlight">\(\theta\)</span> is at the
position where the fitted slope is close to 0.</p>
<figure class="align-default" id="id17">
<a class="reference internal image-reference" href="_images/KBalign.png"><img alt="_images/KBalign.png" src="_images/KBalign.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The fitted slope for the above measured curves.</span><a class="headerlink" href="#id17" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Please refer to the paper <a class="reference internal" href="#huxstoepaperfast" id="id12"><span>[HuXSTOEPaperFast]</span></a> for more details.</p>
</section>
<section id="hartmann-like-data-processing-scheme">
<span id="exphart"></span><h2>Hartmann-like data processing scheme<a class="headerlink" href="#hartmann-like-data-processing-scheme" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please find the example code from <em>/spexwavepy/examples/Hartmann.py</em></p>
</div>
<p>We have also implemented a speckle-based data processing methods that
resemble the conventional Hartmann-like data processing method.
We will demonstrate it in this example.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">ROI_sam</span> <span class="o">=</span> <span class="p">[</span><span class="mi">540</span><span class="p">,</span> <span class="mi">1570</span><span class="p">,</span> <span class="mi">750</span><span class="p">,</span> <span class="mi">1800</span><span class="p">]</span>
<span class="n">ROI_ref</span> <span class="o">=</span> <span class="n">ROI_sam</span>

<span class="n">Imstack_sam</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(,</span> <span class="n">ROI_sam</span><span class="p">)</span>
<span class="n">Imstack_ref</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">ref_folder</span><span class="p">,</span> <span class="n">ROI_ref</span><span class="p">)</span>
<span class="n">Imstack_sam</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
<span class="n">Imstack_ref</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
</pre></div>
</div>
<p>For this data processing mode, one reference and one sample image stack
are needed. There will be only one image in each image stack.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">Imstack_sam</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Imstack_ref</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1030</span><span class="p">,</span> <span class="mi">1050</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1030</span><span class="p">,</span> <span class="mi">1050</span><span class="p">)</span>
</pre></div>
</div>
<p>For Hartmann-like data processing mode, we need to define the subregions used for
pattern shift tracking. The subregion is a rectangular box.
We need to define the centre and the size of each box.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">x_cens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">1050</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">y_cens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">size</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div>
</div>
<p>According to the <a class="reference internal" href="userguide.html#trahart"><span class="std std-ref">implementation of the Hartmann-like method</span></a>,
the real size for the subregion is <span class="math notranslate nohighlight">\(2 \times size\)</span> for both width and height.
We use <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.Hartmann_mesh_show" title="spexwavepy.corefun.Hartmann_mesh_show"><code class="xref py py-func docutils literal notranslate"><span class="pre">Hartmann_mesh_show()</span></code></a> function to show the subregions
defined for the Hartmann-like data processing method.
Note the coordinates of the boxes need to be expanded to 2D mesh grid when as the input of
the <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.Hartmann_mesh_show" title="spexwavepy.corefun.Hartmann_mesh_show"><code class="xref py py-func docutils literal notranslate"><span class="pre">Hartmann_mesh_show()</span></code></a> function.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">spexwavepy.corefun</span> <span class="kn">import</span> <span class="n">Hartmann_mesh_show</span>

<span class="n">X_cens</span><span class="p">,</span> <span class="n">Y_cens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_cens</span><span class="p">,</span> <span class="n">y_cens</span><span class="p">)</span>
<span class="n">Hartmann_mesh_show</span><span class="p">(</span><span class="n">Imstack_ref</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_cens</span><span class="p">,</span> <span class="n">Y_cens</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The chosen rectangular boxes are shown in red in the following image.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/Hartmann1.png"><img alt="_images/Hartmann1.png" src="_images/Hartmann1.png" style="width: 80%;" /></a>
</figure>
<p>Like other data processing methods, we need to define the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class. Then we invoke
the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.Hartmann_XST" title="spexwavepy.trackfun.Tracking.Hartmann_XST"><code class="xref py py-func docutils literal notranslate"><span class="pre">Hartmann_XST()</span></code></a> function
to obtain the speckle pattern shifts.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">Track_Hartmann</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">Imstack_sam</span><span class="p">,</span> <span class="n">Imstack_ref</span><span class="p">)</span>
<span class="n">pad</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">Track_Hartmann</span><span class="o">.</span><span class="n">Hartmann_XST</span><span class="p">(</span><span class="n">X_cens</span><span class="p">,</span> <span class="n">Y_cens</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<p>The calculated speckle patterns shifts are stored in <code class="docutils literal notranslate"><span class="pre">Tracking.delayX</span></code> and
<code class="docutils literal notranslate"><span class="pre">Tracking.delayY</span></code>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Track_Hartmann</span><span class="o">.</span><span class="n">delayX</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Track_Hartmann</span><span class="o">.</span><span class="n">delayY</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/Hartmann2.jpg"><img alt="_images/Hartmann2.jpg" src="_images/Hartmann2.jpg" style="width: 80%;" /></a>
</figure>
<p>The above results resemble those in the <a class="reference internal" href="getstart.html#tucrl"><span class="std std-ref">Tutorial</span></a>.
However, the above results have worse spatial resolution.</p>
<p>Unlike the other data processing methods, for Hartmann-like
method, we only keep speckle tracking shifts, the physical quantities such as
wavefront slope and curvature are left to user to recover.
For more detailed description of this method, please refer to the
<a class="reference internal" href="userguide.html#trahart"><span class="std std-ref">user guide</span></a>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Examples</a><ul>
<li><a class="reference internal" href="#plane-mirror-measurement-with-reference-beam">Plane mirror measurement with reference beam</a></li>
<li><a class="reference internal" href="#measurement-of-the-wavefront-local-curvature-after-a-plane-mirror">Measurement of the wavefront local curvature after a plane mirror</a></li>
<li><a class="reference internal" href="#mirror-slope-error-curve-1d-reconstructed-from-the-dowmstream-setup">Mirror slope error curve (1D) reconstructed from the dowmstream setup</a></li>
<li><a class="reference internal" href="#comparison-between-self-reference-xss-technique-and-self-reference-xst-technique">Comparison between self-reference XSS technique and self-reference XST technique</a></li>
<li><a class="reference internal" href="#kb-mirror-alignment-using-self-reference-xst-technique">KB mirror alignment using self-reference XST technique</a></li>
<li><a class="reference internal" href="#hartmann-like-data-processing-scheme">Hartmann-like data processing scheme</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="getstart.html"
                          title="previous chapter">Getting started</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="userguide.html"
                          title="next chapter">User guide</a></p>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="userguide.html" title="User guide"
             >next</a> |</li>
        <li class="right" >
          <a href="getstart.html" title="Getting started"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">spexwavepy 1.0.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Examples</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2024, Lingfei Hu, Hongchang Wang.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>