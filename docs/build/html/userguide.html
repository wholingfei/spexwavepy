<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>User guide &mdash; spexwavepy 1.0.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API reference" href="api.html" />
    <link rel="prev" title="Examples" href="example.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            spexwavepy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="principle.html">The speckle-based wavefront sensing techniques</a></li>
<li class="toctree-l1"><a class="reference internal" href="getstart.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="example.html">Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">User guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#fundamental-algorithm">Fundamental algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cross-correlation">Cross-correlation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sub-pixel-registration">Sub-pixel registration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default-method">Default method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gaussian-peak-finding-method">Gaussian peak finding method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parabola-peak-finding-method">Parabola peak finding method</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#image-match">Image match</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#image-normalization">Image normalization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#auxiliary-functions">Auxiliary functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#image-stack-and-its-functions">Image stack and its functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#image-stack">Image stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-reading">Data reading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preprocessing-of-the-images">Preprocessing of the images</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#normalization">Normalization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#smoothing">Smoothing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fliping-the-images">Fliping the images</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rotating-the-images">Rotating the images</a></li>
<li class="toctree-l4"><a class="reference internal" href="#detector-pixel-size-determination">Detector pixel size determination</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-speckle-based-techniques-included-in-tracking-class">The speckle-based techniques included in <code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code> class</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#stability-checking-using-speckle-patterns">Stability checking using speckle patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference-and-sample-image-stacks-collimating-before-tracking">Reference and sample image stacks collimating before tracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xss-technique-with-reference-beam">XSS technique with reference beam</a></li>
<li class="toctree-l3"><a class="reference internal" href="#self-reference-xss-technique">Self-reference XSS technique</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xst-technique-with-reference-beam">XST technique with reference beam</a></li>
<li class="toctree-l3"><a class="reference internal" href="#self-reference-xst-technique">Self-reference XST technique</a></li>
<li class="toctree-l3"><a class="reference internal" href="#xsvt-technique">XSVT technique</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#post-processing-of-the-tracked-speckle-pattern-shifts">Post processing of the tracked speckle pattern shifts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#d-integration-for-post-processing">2D integration for post processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slope-reconstruction">Slope reconstruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-curvature-reconstruction">Local curvature reconstruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-integration-from-the-slope">2D integration from the slope</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">spexwavepy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">User guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/userguide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="user-guide">
<h1>User guide<a class="headerlink" href="#user-guide" title="Permalink to this heading"></a></h1>
<p>In this page, we will give a detailed explanation of this python package.
All the crucial functions in each module will be covered.</p>
<section id="fundamental-algorithm">
<span id="usealgorithm"></span><h2>Fundamental algorithm<a class="headerlink" href="#fundamental-algorithm" title="Permalink to this heading"></a></h2>
<p>This section introduce the basic algorithm we used for the various speckle tracking techniques.
Most functions described in this section comes from the <a class="reference internal" href="spexwavepy.html#module-spexwavepy.corefun" title="spexwavepy.corefun"><code class="xref py py-mod docutils literal notranslate"><span class="pre">corefun</span></code></a> module.</p>
<section id="cross-correlation">
<span id="usecrosscorr"></span><h3>Cross-correlation<a class="headerlink" href="#cross-correlation" title="Permalink to this heading"></a></h3>
<p>In image processing, cross-correlation is a measure of the similarity of two images.
For template matching, the template image moves along the surface of the reference image.
At each position, a cross-correlation calculation is conducted.
The output of these cross-correlation calculations is a coefficient matrix.
This matrix is often used to estimate how the two images resemble.
According to the mode of cross-correlation used, usually,
the largest or smallest value in the coefficient matrix corresponds to the position
the template image and the reference image resemble the most.</p>
<figure class="align-default" id="id12">
<a class="reference internal image-reference" href="_images/Cross_Correlation_Animation.gif"><img alt="_images/Cross_Correlation_Animation.gif" src="_images/Cross_Correlation_Animation.gif" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text">Animation of the cross-correlation sliding a template over an image. (Image is from wikipedia.)</span><a class="headerlink" href="#id12" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The <strong>normalized cross-correlation</strong> is used to obtain the coefficient matrix in this package.
This matrix can provide the pixel-wise location of the highest correlation.
It is also used to obtain the sub-pixel registration, which we will cover in the next section <a class="reference internal" href="#usesubpix"><span class="std std-ref">Sub-pixel registration</span></a>.</p>
<p>If <span class="math notranslate nohighlight">\(t(x,y)\)</span> is the template image,
<span class="math notranslate nohighlight">\(f(x,y)\)</span> is the sub-image of the raw image which is to be cross-correlated,
then the <strong>normalized cross-correlation</strong> is:</p>
<div class="math notranslate nohighlight">
\[R(x,y) = \frac{1}{n} \sum\limits_{x',y'}\frac{1}{\sigma_{t}\sigma_{f}} (t(x',y') - \bar t)(f(x+x', y+y') - \bar f(x, y))\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of pixels in <span class="math notranslate nohighlight">\(t(x', y')\)</span> and <span class="math notranslate nohighlight">\(f(x+x', y+y')\)</span>,
<span class="math notranslate nohighlight">\(\bar t\)</span> and <span class="math notranslate nohighlight">\(\bar f(x, y)\)</span> are the average of <span class="math notranslate nohighlight">\(t(x', y')\)</span> and <span class="math notranslate nohighlight">\(f(x+x', y+y')\)</span>, respectively.</p>
<p>The OpenCv-Python (cv2) package is heavily used in this package.
Especially, we use the existing <code class="docutils literal notranslate"><span class="pre">cv2.matchTemplate</span></code> function to calculate the cross-correlation matrix.
The standard normalized cross-correlation shown above corresponds to
the <code class="docutils literal notranslate"><span class="pre">TM_CCOEFF_NORMED</span></code> method for the existing template matching function.
Other methods haven’t been implemented in this package.</p>
<p>For more information of the <strong>template matching</strong> in OpenCv-Python (cv2) package,
please refer to <a class="reference external" href="https://docs.opencv.org/3.4/de/da9/tutorial_template_matching.html">this link</a>.</p>
</section>
<section id="sub-pixel-registration">
<span id="usesubpix"></span><h3>Sub-pixel registration<a class="headerlink" href="#sub-pixel-registration" title="Permalink to this heading"></a></h3>
<p>We provide three sub-pixel registration methods at present.
They are the differential approach (the default method), Gaussian peak locating, and parabola curve peak locating.
Other methods can be easily implemented if required.</p>
<p>The subpixel registration functions are defined in <a class="reference internal" href="spexwavepy.html#module-spexwavepy.corefun" title="spexwavepy.corefun"><code class="xref py py-mod docutils literal notranslate"><span class="pre">corefun</span></code></a> module.</p>
<section id="default-method">
<span id="subdefault"></span><h4>Default method<a class="headerlink" href="#default-method" title="Permalink to this heading"></a></h4>
<p>The default sub-pixel registration method can be found in <a class="reference internal" href="#defaultref1" id="id1"><span>[defaultref1]</span></a> and <a class="reference internal" href="#defaultref2" id="id2"><span>[defaultref2]</span></a>.</p>
<p>This method can be described in the following.
The method can be described in the following.
We assume the coefficient matrix obtained from the cross-correlation to be <span class="math notranslate nohighlight">\(R(x,y)\)</span>.
It has the pixel-wise maximum value at <span class="math notranslate nohighlight">\((x_0, y_0)\)</span>.
<span class="math notranslate nohighlight">\((x_0, y_0)\)</span> is the index of the pixel.
We assume the cross-correlation has its maximum value at the position of <span class="math notranslate nohighlight">\((x_0+\delta x, y_0+\delta y)\)</span>.
Then we have:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\delta x = \left( \frac{\partial^{2} R}{\partial y^{2}} \frac{\partial R}{\partial x}
- \frac{\partial^{2} R}{\partial x \partial y} \frac{\partial R}{\partial y} \right)
 \left( \left( \frac{\partial^{2} R}{\partial x \partial y} \right)^{2}
- \frac{\partial^{2} R}{\partial x^{2}} \frac{\partial^{2} R}{\partial y^{2}} \right)^{-1}\\\delta y = \left( \frac{\partial^{2} R}{\partial x^{2}} \frac{\partial R}{\partial y}
- \frac{\partial^{2} R}{\partial x \partial y} \frac{\partial R}{\partial x} \right)
 \left( \left( \frac{\partial^{2} R}{\partial x \partial y} \right)^{2}
- \frac{\partial^{2} R}{\partial x^{2}} \frac{\partial^{2} R}{\partial y^{2}} \right)^{-1}\end{aligned}\end{align} \]</div>
<p>To discrete the above partial differential operators, the central difference scheme is used.</p>
</section>
<section id="gaussian-peak-finding-method">
<span id="subgauss"></span><h4>Gaussian peak finding method<a class="headerlink" href="#gaussian-peak-finding-method" title="Permalink to this heading"></a></h4>
<p>Both this method and <a class="reference internal" href="#subpara"><span class="std std-ref">Parabola peak finding method</span></a> can be find in <a class="reference internal" href="#gaussref1" id="id3"><span>[gaussref1]</span></a>.</p>
<p>Assuming the coefficient matrix <span class="math notranslate nohighlight">\(R(x, y)\)</span> can be fitted by a 2D Gaussian function,
the peak location of the fitted function is:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x_m = x_0 + \frac{\ln(R(x_{0}-1, y_{0}))-\ln(R(x_{0}+1, y_{0}))}{2\ln(R(x_{0}+1, y_{0}))-4\ln(R(x_{0}, y_{0}))+2\ln(R(x_{0}-1, y_{0}))}\\y_m = x_0 + \frac{\ln(R(x_{0}, y_{0}-1))-\ln(R(x_{0}, y_{0}+1))}{2\ln(R(x_{0}, y_{0}+1))-4\ln(R(x_{0}, y_{0}))+2\ln(R(x_{0}, y_{0}-1))}\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(y_0\)</span> are the pixel indices in the two dimensions with the maximum value of <span class="math notranslate nohighlight">\(R(x, y)\)</span>.</p>
</section>
<section id="parabola-peak-finding-method">
<span id="subpara"></span><h4>Parabola peak finding method<a class="headerlink" href="#parabola-peak-finding-method" title="Permalink to this heading"></a></h4>
<p>Resemble to Gaussian peak finding method,
parabola peak finding method assumes the coefficient matrix <span class="math notranslate nohighlight">\(R(x, y)\)</span> can be fitted by a 2D parabolic function.
The peak location of the fitted function is:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x_m = x_0 + \frac{R(x_{0}-1, y_{0})-R(x_{0}+1, y_{0})}{2R(x_{0}+1, y_{0})-4R(x_{0}, y_{0})+2R(x_{0}-1, y_{0})}\\y_m = x_0 + \frac{R(x_{0}, y_{0}-1)-R(x_{0}, y_{0}+1)}{2R(x_{0}, y_{0}+1)-4R(x_{0}, y_{0})+2R(x_{0}, y_{0}-1)}\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(y_0\)</span> are the pixel indices in the two dimensions with the maximum value of <span class="math notranslate nohighlight">\(R(x, y)\)</span>.</p>
<div role="list" class="citation-list">
<div class="citation" id="defaultref1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">defaultref1</a><span class="fn-bracket">]</span></span>
<p>Fisher, G. H., &amp; Welsch, B.T.
“FLCT: a fast, efficient method for performing local correlation tracking.”
Subsurface and Atmospheric Influences on Solar Activity. Vol. 383. 2008.</p>
</div>
<div class="citation" id="defaultref2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">defaultref2</a><span class="fn-bracket">]</span></span>
<p>Qiao, Zhi, et al.
“Wavelet-transform-based speckle vector tracking method for X-ray phase imaging.”
Optics Express 28.22 (2020): 33053-33067.</p>
</div>
<div class="citation" id="gaussref1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">gaussref1</a><span class="fn-bracket">]</span></span>
<p>Debella-Gilo, M, and Kääb, A.
“Sub-pixel precision image matching for measuring surface displacements on mass movements using normalized cross-correlation.”
Remote Sensing of Environment 115.1 (2011): 130-142.</p>
</div>
</div>
</section>
</section>
<section id="image-match">
<span id="useimmatch"></span><h3>Image match<a class="headerlink" href="#image-match" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.Imagematch" title="spexwavepy.corefun.Imagematch"><code class="xref py py-func docutils literal notranslate"><span class="pre">Imagematch()</span></code></a> function from the
<a class="reference internal" href="spexwavepy.html#module-spexwavepy.corefun" title="spexwavepy.corefun"><code class="xref py py-mod docutils literal notranslate"><span class="pre">corefun</span></code></a> module is the basic function this package
calls to do the cross-correlation. It wraps <code class="docutils literal notranslate"><span class="pre">cv2.matchTemplate</span></code> function
and several sub-pixel registration methods. The two mandatory inputs are two images,
<code class="docutils literal notranslate"><span class="pre">im1</span></code> and <code class="docutils literal notranslate"><span class="pre">im2</span></code>. <code class="docutils literal notranslate"><span class="pre">im2</span></code> by definition must be smaller than <code class="docutils literal notranslate"><span class="pre">im1</span></code>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">delayX</span><span class="p">,</span> <span class="n">delayY</span><span class="p">,</span> <span class="n">res_mat</span> <span class="o">=</span> <span class="n">Imagematch</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">)</span>
</pre></div>
</div>
<p>This function returns tracked shifts (<code class="docutils literal notranslate"><span class="pre">delayX</span></code> and <code class="docutils literal notranslate"><span class="pre">delayY</span></code>) betweeen <code class="docutils literal notranslate"><span class="pre">im1</span></code> and <code class="docutils literal notranslate"><span class="pre">im2</span></code>
and also the related cross-correlatin coefficient matrix <code class="docutils literal notranslate"><span class="pre">res_mat</span></code> (if <code class="docutils literal notranslate"><span class="pre">res</span></code> is True).</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/imagematch.jpg"><img alt="_images/imagematch.jpg" src="_images/imagematch.jpg" style="width: 80%;" /></a>
</figure>
<section id="image-normalization">
<span id="usenorm"></span><h4>Image normalization<a class="headerlink" href="#image-normalization" title="Permalink to this heading"></a></h4>
<p>We do normalization to mitigate the impact of the non-uniformity of the images.</p>
<a class="reference internal image-reference" href="_images/rawimage.JPG"><img alt="_images/rawimage.JPG" src="_images/rawimage.JPG" style="width: 40%;" /></a>
<p>Wherever to do the normalization, the basic function to call is
<a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.NormImage" title="spexwavepy.corefun.NormImage"><code class="xref py py-func docutils literal notranslate"><span class="pre">NormImage()</span></code></a>.
The process is as follows.</p>
<p><span class="math notranslate nohighlight">\(b_j\)</span> and <span class="math notranslate nohighlight">\(c_i\)</span> are the partial sums of each column and row of the raw image, respectively.</p>
<a class="reference internal image-reference" href="_images/rowsum.JPG"><img alt="_images/rowsum.JPG" src="_images/rowsum.JPG" style="width: 40%;" /></a>
<a class="reference internal image-reference" href="_images/colsum.JPG"><img alt="_images/colsum.JPG" src="_images/colsum.JPG" style="width: 40%;" /></a>
<p><span class="math notranslate nohighlight">\(\bar{a}_{i,j}\)</span> is generated as the following.
First, for every index <span class="math notranslate nohighlight">\(j\)</span>, the column of the raw image, <span class="math notranslate nohighlight">\(a_{i,j}\)</span>, divides <span class="math notranslate nohighlight">\(b_j\)</span>.
Second, after the above first step, for every index <span class="math notranslate nohighlight">\(i\)</span>, the row of the generated image divides <span class="math notranslate nohighlight">\(c_i\)</span>.</p>
<p>Then we do the common normalization.
<span class="math notranslate nohighlight">\(\bar{a}\)</span> is the mean value of <span class="math notranslate nohighlight">\(\bar{a}_{i,j}\)</span>, <span class="math notranslate nohighlight">\(\sigma\)</span> is the std of <span class="math notranslate nohighlight">\(\bar{a}_{i,j}\)</span>,
then we have each element of the final generated image as <span class="math notranslate nohighlight">\((\bar{a}_{i,j}-\bar{a})/\sigma\)</span>.</p>
<p>As the images shown in the following, the main purpose of doing normalization is to
get rid of the “wrinkles” come from the incident beam. If the normalization is not
effect to the raw images, we recommend to do the normalization to the stiched images later.
Besides, if the incident beam is clean enough, there is no need to do the normalization.</p>
<a class="reference internal image-reference" href="_images/normCRL.png"><img alt="_images/normCRL.png" src="_images/normCRL.png" style="width: 100%;" /></a>
</section>
</section>
<section id="auxiliary-functions">
<span id="useauxfunc"></span><h3>Auxiliary functions<a class="headerlink" href="#auxiliary-functions" title="Permalink to this heading"></a></h3>
<p>We provide functions <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.read_one" title="spexwavepy.corefun.read_one"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_one()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.crop_one" title="spexwavepy.corefun.crop_one"><code class="xref py py-func docutils literal notranslate"><span class="pre">crop_one()</span></code></a> in the <a class="reference internal" href="spexwavepy.html#module-spexwavepy.corefun" title="spexwavepy.corefun"><code class="xref py py-mod docutils literal notranslate"><span class="pre">corefun</span></code></a> module
to help the user read one image into the memory and see it and crop it.</p>
<p>To call <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.read_one" title="spexwavepy.corefun.read_one"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_one()</span></code></a> function,
you need to input the file path of the image that you want to read.
If <code class="docutils literal notranslate"><span class="pre">ShowImage</span></code> is set to be True, then it will show the loaded single image automatically
after you call this function.</p>
<p>The <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.crop_one" title="spexwavepy.corefun.crop_one"><code class="xref py py-func docutils literal notranslate"><span class="pre">crop_one()</span></code></a> function has a parameter <code class="docutils literal notranslate"><span class="pre">ROI</span></code> to set
the region of interest to be cropped from the loaded raw image. To correctely call
this function, the user need to use <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.read_one" title="spexwavepy.corefun.read_one"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_one()</span></code></a> function to
load the raw image into memory. The following is the an example of a piece of codes
the user need to crop the raw image and to show it. The raw image is loaded into
memory and assigned to <code class="docutils literal notranslate"><span class="pre">im_raw</span></code>. Then <code class="docutils literal notranslate"><span class="pre">im_raw</span></code> is paased to <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.read_one" title="spexwavepy.corefun.read_one"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_one()</span></code></a>
function. The <code class="docutils literal notranslate"><span class="pre">ShowImage</span></code> parameter is the same as <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.read_one" title="spexwavepy.corefun.read_one"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_one()</span></code></a>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">im_raw</span> <span class="o">=</span> <span class="n">read_one</span><span class="p">(</span><span class="n">filepath</span><span class="o">=</span><span class="n">IMAGE</span> <span class="o">/</span> <span class="n">FILE</span> <span class="o">/</span> <span class="n">PATH</span><span class="p">,</span> <span class="n">ShowImage</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ROI</span> <span class="o">=</span> <span class="p">[</span><span class="mi">750</span><span class="p">,</span> <span class="mi">1500</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">2000</span><span class="p">]</span>    <span class="c1">#[y_start, y_end, x_start, x_end]</span>
<span class="n">im_crop</span> <span class="o">=</span> <span class="n">crop_one</span><span class="p">(</span><span class="n">im_raw</span><span class="p">,</span> <span class="n">ROI</span><span class="p">,</span> <span class="n">ShowImage</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ROI=[y_start,</span> <span class="pre">y_end,</span> <span class="pre">x_start,</span> <span class="pre">x_end]</span></code>. The first two parameters of <code class="docutils literal notranslate"><span class="pre">ROI</span></code> is
the start and the end position of y coordinate, the last parameters of <code class="docutils literal notranslate"><span class="pre">ROI</span></code> is
the start and the end position of x coordinate. The start and the end coordinates are shown below.</p>
<a class="reference internal image-reference" href="_images/readone.png"><img alt="_images/readone.png" src="_images/readone.png" style="width: 80%;" /></a>
</section>
</section>
<section id="image-stack-and-its-functions">
<span id="useimstackclass"></span><h2>Image stack and its functions<a class="headerlink" href="#image-stack-and-its-functions" title="Permalink to this heading"></a></h2>
<p>To use this python package to process the experiment data,
you need to load the acquired image data into an image stack.
A class is defined to achieve this.
Other reltated functions are also been covered in this
<a class="reference internal" href="spexwavepy.html#module-spexwavepy.imstackfun" title="spexwavepy.imstackfun"><code class="xref py py-mod docutils literal notranslate"><span class="pre">imstackfun</span></code></a> module.</p>
<section id="image-stack">
<span id="useimstack"></span><h3>Image stack<a class="headerlink" href="#image-stack" title="Permalink to this heading"></a></h3>
<p>From all the given <a class="reference internal" href="example.html"><span class="doc">examples</span></a>,
the first thing you need to do is to creat the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class.
It is the image stack serves as a container for the acquired images which are read into the memory.</p>
<p>A typical excerpt of the code to create the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class is
as follows:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">spexwavepy.imstackfun</span> <span class="kn">import</span> <span class="n">Imagestack</span>

<span class="n">folder_path</span> <span class="o">=</span> <span class="s2">&quot;/Your/data/folder/path/&quot;</span>
<span class="n">ROI</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2048</span><span class="p">]</span>
<span class="n">imstack</span> <span class="o">=</span> <span class="n">Imagestack</span><span class="p">(</span><span class="n">fileFolder</span><span class="o">=</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">ROI</span><span class="o">=</span><span class="n">ROI</span><span class="p">)</span>
</pre></div>
</div>
<p>Two parameters are needed as the input to create the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class.
<code class="docutils literal notranslate"><span class="pre">fileFolder</span></code> is the data folder path for the acquired images,
<code class="docutils literal notranslate"><span class="pre">ROI</span></code> is the region of interest to be cropped from the raw image.
<code class="docutils literal notranslate"><span class="pre">ROI=[y_start,</span> <span class="pre">y_end,</span> <span class="pre">x_start,</span> <span class="pre">x_end]</span></code>.
Its defination can also be found in the <a class="reference internal" href="#useauxfunc"><span class="std std-ref">above section</span></a>.</p>
</section>
<section id="data-reading">
<h3>Data reading<a class="headerlink" href="#data-reading" title="Permalink to this heading"></a></h3>
<p>There are other properties that are automatically defined when initiating the
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class.
Most of them relate to the raw data reading.</p>
<p><code class="docutils literal notranslate"><span class="pre">fstart</span></code> defines the number of the first image to be loaded into memory. The default value is 0.
That means the first image. Otherwise, data loading will be start from image number of <code class="docutils literal notranslate"><span class="pre">fstart</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">fstep</span></code> defines the step of the data reading when iterating over the dataset. The default value is 1.
That means to read every image until it reaches the designated end.</p>
<p><code class="docutils literal notranslate"><span class="pre">fnum</span></code> defines the total number of images to be read in the dataset. The default value is negative.
That means to read all the files in the dataset.
If it is a positive number, the number of images reading into memory equals the value of <code class="docutils literal notranslate"><span class="pre">fnum</span></code>.</p>
<p>After properly defining the above attributes, the following code can be used to read the data:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">read_data</span><span class="p">()</span>
</pre></div>
</div>
<p>The above code is not mandatory. The raw data can be loaded later as long as the <code class="docutils literal notranslate"><span class="pre">rawdata</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>The <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.read_data" title="spexwavepy.imstackfun.Imagestack.read_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_data()</span></code></a> method of the
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class is called to load the data into the memory.
After the invoking of this method, the raw data is stored in the read-only <code class="docutils literal notranslate"><span class="pre">rawdata</span></code> attribute,
the same raw data is also stored in the <code class="docutils literal notranslate"><span class="pre">data</span></code> attribute.
This attribute can be modified when other methods are called.</p>
<p>In general, <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.read_data" title="spexwavepy.imstackfun.Imagestack.read_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_data()</span></code></a> method reads from
the image start with the number of <code class="docutils literal notranslate"><span class="pre">fstart</span></code>,
with the loading step of <code class="docutils literal notranslate"><span class="pre">fstep</span></code>, total image number of <code class="docutils literal notranslate"><span class="pre">fnum</span></code>.</p>
</section>
<section id="preprocessing-of-the-images">
<span id="usepreprocess"></span><h3>Preprocessing of the images<a class="headerlink" href="#preprocessing-of-the-images" title="Permalink to this heading"></a></h3>
<p>There are some other methods defined in <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class.
They are mainly used to preprocess the raw images in the image stack.</p>
<section id="normalization">
<span id="usenormstack"></span><h4>Normalization<a class="headerlink" href="#normalization" title="Permalink to this heading"></a></h4>
<p>The <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.norm" title="spexwavepy.imstackfun.Imagestack.norm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">norm()</span></code></a> method is called to normalize the raw images in
the image stack. The normalization algorithm used for each image is described in the
<a class="reference internal" href="#usenorm"><span class="std std-ref">above section</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are two places in this package to do the normalization.
One is to normalize the raw images, the other one is to normalize the
stitched images (see in the following sections for the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class).
<strong>Usually, we only choose one place to do the normalization.</strong></p>
</div>
<p>If you want to do the normalization for the raw images in the dataset,
set the <code class="docutils literal notranslate"><span class="pre">normalize</span></code> attribute to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Then when you call the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.read_data" title="spexwavepy.imstackfun.Imagestack.read_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_data()</span></code></a> function,
the raw images will be normalized during data loading.</p>
<p>Another way is to explicitly call <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.norm" title="spexwavepy.imstackfun.Imagestack.norm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">norm()</span></code></a> method:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="smoothing">
<span id="usesmooth"></span><h4>Smoothing<a class="headerlink" href="#smoothing" title="Permalink to this heading"></a></h4>
<p>If the raw image quaility is very low, sometimes you need to smooth it.
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.smooth" title="spexwavepy.imstackfun.Imagestack.smooth"><code class="xref py py-func docutils literal notranslate"><span class="pre">smooth()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.smooth_multi" title="spexwavepy.imstackfun.Imagestack.smooth_multi"><code class="xref py py-func docutils literal notranslate"><span class="pre">smooth_multi()</span></code></a> functions are
used to smooth the raw images in the image stack. The latter is the
multiprocessing version of the former. Two smoothing methods are available at
present, they are <code class="docutils literal notranslate"><span class="pre">Gaussian</span></code> and <code class="docutils literal notranslate"><span class="pre">Box</span></code>, respectively. If the
<code class="docutils literal notranslate"><span class="pre">meth</span></code> is <code class="docutils literal notranslate"><span class="pre">Gaussian</span></code>, a Gaussian function will be used for the
smoothing, the parameter of <code class="docutils literal notranslate"><span class="pre">pixel</span></code> determines the sigma of the
Gaussian function. If the <code class="docutils literal notranslate"><span class="pre">meth</span></code> is <code class="docutils literal notranslate"><span class="pre">Box</span></code>, a <span class="math notranslate nohighlight">\(n \times n\)</span>
matrix is used to convolve the raw image, each element in the matrix
equals to <span class="math notranslate nohighlight">\(1/n^2\)</span>. Likewise, the parameter of <code class="docutils literal notranslate"><span class="pre">pixel</span></code> is used
to determine <span class="math notranslate nohighlight">\(n\)</span>. The following images show how the smoothing
will look like.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/smoothing.png"><img alt="_images/smoothing.png" src="_images/smoothing.png" style="width: 100%;" /></a>
</figure>
<p>To do the smoothing, you need to call the following function with parameters <code class="docutils literal notranslate"><span class="pre">meth</span></code> and <code class="docutils literal notranslate"><span class="pre">pixel</span></code>:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">meth</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbos</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="fliping-the-images">
<span id="useflip"></span><h4>Fliping the images<a class="headerlink" href="#fliping-the-images" title="Permalink to this heading"></a></h4>
<p>Sometimes you need to flip the images in the dataset to match the reference image,
such as to measure <a class="reference internal" href="example.html#expplane"><span class="std std-ref">a planar mirror using XSS technique with reference beam</span></a>.</p>
<p>An attribute <code class="docutils literal notranslate"><span class="pre">flip</span></code> is used to tell the codes how to flip the image.
The default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>. The acceptable values are <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>If</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">flip</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
</pre></div>
</div>
<p>The raw images in the dataset will flip in the horizontal direction when
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.read_data" title="spexwavepy.imstackfun.Imagestack.read_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_data()</span></code></a> function is called.</p>
<p>Otherwise,</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">flip</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
</pre></div>
</div>
<p>The raw images in the dataset will flip in the vertical direction when
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.read_data" title="spexwavepy.imstackfun.Imagestack.read_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_data()</span></code></a> function is called.</p>
<figure class="align-default" id="id13">
<a class="reference internal image-reference" href="_images/Flip.png"><img alt="_images/Flip.png" src="_images/Flip.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text">On the left is the raw image. In the middle is the image flipped horizontally, Imagestack.flip=’x’.
On the right is the image flipped vertically, Imagestack.flip=’y’.</span><a class="headerlink" href="#id13" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>You can also directly call <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.flipstack" title="spexwavepy.imstackfun.Imagestack.flipstack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flipstack()</span></code></a> method once the above
attribute has been set:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">flipstack</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="rotating-the-images">
<span id="userot"></span><h4>Rotating the images<a class="headerlink" href="#rotating-the-images" title="Permalink to this heading"></a></h4>
<p>In some cases, you need to rotate the raw images for some degrees,
such as in the example of <a class="reference internal" href="example.html#expplane"><span class="std std-ref">plane mirror measurement with reference beam</span></a>.</p>
<p>Two methods are provided to do the rotation.
One is to rotate the raw images 90 degrees counterclockwise.
The method name is <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.rot90deg" title="spexwavepy.imstackfun.Imagestack.rot90deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rot90deg()</span></code></a>.
To call this method:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">rot90deg</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="id14">
<a class="reference internal image-reference" href="_images/rot90deg.png"><img alt="_images/rot90deg.png" src="_images/rot90deg.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text">On the left is the raw image, on the right is the rotated image.
The rotation is 90 degrees counterclockwise.</span><a class="headerlink" href="#id14" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Another method is <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack.rotate" title="spexwavepy.imstackfun.Imagestack.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">imstack</span><span class="o">.</span><span class="n">rot90deg</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>      <span class="c1"># In [deg]</span>
</pre></div>
</div>
<figure class="align-default" id="id15">
<a class="reference internal image-reference" href="_images/rotate45deg.png"><img alt="_images/rotate45deg.png" src="_images/rotate45deg.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text">On the left is the raw image. In the middle is the image ratated with +45 degrees.
On the right is the image rotated with -45 degrees.</span><a class="headerlink" href="#id15" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="detector-pixel-size-determination">
<span id="usedetpix"></span><h4>Detector pixel size determination<a class="headerlink" href="#detector-pixel-size-determination" title="Permalink to this heading"></a></h4>
<p>To determine the detector pixel size,
we scan the diffuser in one direction with a relatively large step at first,
10 um for example. The speckle pattern will move according to the scan.
If the scan direction is along the x-axis,
the speckle pattern will move along the x-axis too.</p>
<a class="reference internal image-reference" href="_images/pixdet1.jpg"><img alt="_images/pixdet1.jpg" src="_images/pixdet1.jpg" style="width: 80%;" /></a>
<p>We choose a subregion from each image to track the speckle pattern movement using cross-correlation.
The tracked moving is in the unit of pixels.
All the images extracted from the subregion are compared with the first raw image.
Thus, the tracked speckle pattern shifts will be along a straight line.
We fit the tracked shifts into a straight line,
and the pixel size is calculated by 1 over the slope of the fitted line.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">subregion</span></code> set in this function is related to the cropped image stack.
That is to say, if we have set <code class="docutils literal notranslate"><span class="pre">ROI</span></code> for the image stack, then the <code class="docutils literal notranslate"><span class="pre">subROI</span></code>
parameter is the coordinate to the newly cropped images by <code class="docutils literal notranslate"><span class="pre">ROI</span></code>, <strong>NOT</strong> to
the raw images.</p>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">display</span></code> is True, the fitting results will be shown.</p>
<figure class="align-center" id="id16">
<a class="reference internal image-reference" href="_images/pixdet2.jpg"><img alt="_images/pixdet2.jpg" src="_images/pixdet2.jpg" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-text">The fitting results and the residuals.</span><a class="headerlink" href="#id16" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Please refer to the <a class="reference internal" href="getstart.html#tudetpix"><span class="std std-ref">Tutorial</span></a> for the use of this method.</p>
</section>
</section>
</section>
<section id="the-speckle-based-techniques-included-in-tracking-class">
<span id="usetrack"></span><h2>The speckle-based techniques included in <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class<a class="headerlink" href="#the-speckle-based-techniques-included-in-tracking-class" title="Permalink to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this package, we assume the incident beam is from the quasi-parallel
beam from the synchrotron radiation source going through the beamline
without any other optics except one monochrometer.
If the incident is a quasi-spherical wave, some modifications are needed
for some techniques.</p>
</div>
<p><strong>Should mention upstream and Downstream problem!!! ……</strong></p>
<p>The <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class is the container for the various
speckle-based techniques.
At least one image stack is needed as the input of the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a>
class. These image stacks are defined as the <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> classes.
There are up to 4 image stacks needed
according to the different data processing modes. The following list shows the number of
image stacks needed for different modes.
Each row has the same scan dimension <code class="docutils literal notranslate"><span class="pre">scandim</span></code> for each technique,
each column represnts a specific type of the technique.</p>
<p><code class="docutils literal notranslate"><span class="pre">imstack1</span></code>, <code class="docutils literal notranslate"><span class="pre">imstack2</span></code>, <code class="docutils literal notranslate"><span class="pre">imstack3</span></code>, <code class="docutils literal notranslate"><span class="pre">imstack4</span></code> represent the
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> class needed for each tracking mode.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Scan
dimension</p></th>
<th class="head"><p>XSS self</p></th>
<th class="head"><p>XST self <a class="footnote-reference brackets" href="#id9" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></th>
<th class="head"><p>XSS with
references</p></th>
<th class="head"><p>XST with
reference <a class="footnote-reference brackets" href="#id11" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p></th>
<th class="head"><p>XSVT with
reference</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>x</p></td>
<td><p>imstack1(x
sam)</p></td>
<td><p>imstack1(x
sam1),
2(x sam2)</p></td>
<td><p>imstack1(x
sam),
2(x ref)</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>y</p></td>
<td><p>imstack1(y
sam)</p></td>
<td><p>imsatck1(y
sam1),
2(y sam2)</p></td>
<td><p>imstack1(y
sam),
2(y ref)</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-even"><td><p>xy <a class="footnote-reference brackets" href="#id8" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>-</p></td>
<td><p>imstack1(x
sam1),
2(x sam2),
3(y sam1),
4(y sam2)
<a class="footnote-reference brackets" href="#id10" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p>imstack1(x
sam),
2(x ref),
3(y sam),
4(y ref)</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>random</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>imstack1(sam),
2(ref)</p></td>
<td><p>imstack1(sam),
2(ref)</p></td>
</tr>
</tbody>
</table>
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">1</a><span class="fn-bracket">]</span></span>
<p>The <code class="docutils literal notranslate"><span class="pre">scandim</span></code> set to ‘xy’ is exclusively used for ‘2D’ data processing,
it is valid only when <code class="docutils literal notranslate"><span class="pre">Tracking.dimension</span></code> is ‘2D’.</p>
</aside>
<aside class="footnote brackets" id="id9" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span>
<p>For XST techniques (self or with reference), there will be only one image in each image stacks.</p>
</aside>
<aside class="footnote brackets" id="id10" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">3</a><span class="fn-bracket">]</span></span>
<p>For self-reference XST technique, it is possible that imsatck1 and imstack3 are identical.</p>
</aside>
<aside class="footnote brackets" id="id11" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p>The <code class="docutils literal notranslate"><span class="pre">scandim</span></code> is not valid and not used in XST technique with reference beam.</p>
</aside>
<p>The implementation of each of these tracking modes used
in this package will be introduced in this section.
For the explanation of the physics and theory of these
tracking modes please refer to
<a class="reference internal" href="principle.html"><span class="doc">The speckle-based wavefront sensing techniques</span></a>.</p>
<p>As to the practical implementation of these techniques within this python package,
two essential methods are <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer" title="spexwavepy.trackfun.Tracking.XSS_withrefer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer()</span></code></a>
and <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self" title="spexwavepy.trackfun.Tracking.XST_self"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XST_self()</span></code></a>, as well as their
multiprocessing form of <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer_multi" title="spexwavepy.trackfun.Tracking.XSS_withrefer_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer_multi()</span></code></a>
and <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self_multi" title="spexwavepy.trackfun.Tracking.XST_self_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XST_self_multi()</span></code></a>.
They represent the <a class="reference internal" href="principle.html#prinxssrefer"><span class="std std-ref">XSS technhique with reference beam</span></a> and
<a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">Self-reference XST technique</span></a>, respectively.
Other methods are based upon these two methods.</p>
<p>Apart from the above mentioned speckle-based techniques,
the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class has provided
other auxiliary functions. They are also described in
the following.</p>
<section id="stability-checking-using-speckle-patterns">
<span id="trastable"></span><h3>Stability checking using speckle patterns<a class="headerlink" href="#stability-checking-using-speckle-patterns" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.stability" title="spexwavepy.trackfun.Tracking.stability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stability()</span></code></a> method
defined in the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class
is used for the stability checking.</p>
<p>To do stability checking, the reference image is the <strong>first</strong> image in the image folder.
The rest images are all compared with this reference image.
This tracking mode calls the <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.Imagematch" title="spexwavepy.corefun.Imagematch"><code class="xref py py-func docutils literal notranslate"><span class="pre">Imagematch()</span></code></a> function directly.</p>
<p>Thus, before tracking, the template image will be cut according to the <code class="docutils literal notranslate"><span class="pre">edge_x</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_y</span></code>.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/stable.jpg"><img alt="_images/stable.jpg" src="_images/stable.jpg" style="width: 80%;" /></a>
</figure>
<p>If <code class="docutils literal notranslate"><span class="pre">delayX</span></code> and <code class="docutils literal notranslate"><span class="pre">delayY</span></code> are the tracked results, the real shifts should be
<code class="docutils literal notranslate"><span class="pre">delayX</span></code> - <code class="docutils literal notranslate"><span class="pre">edge_x[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">delayY</span></code> - <code class="docutils literal notranslate"><span class="pre">edge_y[0]</span></code>.</p>
<p>Refer to <a class="reference internal" href="getstart.html#tustable"><span class="std std-ref">Tutorial</span></a> for the use of this method.
The multiprocessing mode of this method named as
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.stability_multi" title="spexwavepy.trackfun.Tracking.stability_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stability_multi()</span></code></a>
is also implemented.</p>
</section>
<section id="reference-and-sample-image-stacks-collimating-before-tracking">
<span id="tracolli"></span><h3>Reference and sample image stacks collimating before tracking<a class="headerlink" href="#reference-and-sample-image-stacks-collimating-before-tracking" title="Permalink to this heading"></a></h3>
<p>There are some occasions that you need to collimate the speckle pattrns from
two image stacks before you do any speckle tracking. It is needed particularly
when the tested  optic is a planar reflecting mirror and we have another
incident beam image stack for reference.
The <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.collimate" title="spexwavepy.trackfun.Tracking.collimate"><code class="xref py py-func docutils literal notranslate"><span class="pre">collimate()</span></code></a> function is designed
for such situation.</p>
<p>In order to use <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.collimate" title="spexwavepy.trackfun.Tracking.collimate"><code class="xref py py-func docutils literal notranslate"><span class="pre">collimate()</span></code></a> function,
two image stacks <a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> need to be defined
and as the input of the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class.</p>
<p>We use the first image from the two image stacks to do the collimation.
Similar to the <a class="reference internal" href="#trastable"><span class="std std-ref">stability check</span></a>,
we cut one image in the first image stack according to <code class="docutils literal notranslate"><span class="pre">edge_x</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_y</span></code>.
Usually a very large area is cropped for collimating.
We still invoke the <a class="reference internal" href="spexwavepy.html#spexwavepy.corefun.Imagematch" title="spexwavepy.corefun.Imagematch"><code class="xref py py-func docutils literal notranslate"><span class="pre">Imagematch()</span></code></a> fucntion to
cross-correlate the two images from two different image stacks.
Finally, we move all the images in the two image stacks
according to the obtained speckle pattern shifts.
After calling this method, all the images in the two image stacks will be aligned.</p>
<p>The following images show that before the collimation,
two images from the different image stacks are not aligned well.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/collima_before.png"><img alt="_images/collima_before.png" src="_images/collima_before.png" style="width: 80%;" /></a>
</figure>
<p>Then we do the collimating.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">spexwavepy.trackfun</span> <span class="kn">import</span> <span class="n">Tracking</span>

<span class="n">track</span> <span class="o">=</span> <span class="n">Tracking</span><span class="p">(</span><span class="n">imstack_sam</span><span class="p">,</span> <span class="n">imstack_ref</span><span class="p">)</span>
<span class="n">track</span><span class="o">.</span><span class="n">collimate</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
</pre></div>
</div>
<p>Where in the above code block, <code class="docutils literal notranslate"><span class="pre">imstack_sam</span></code> and <code class="docutils literal notranslate"><span class="pre">imsatck_ref</span></code> are two
<a class="reference internal" href="spexwavepy.html#spexwavepy.imstackfun.Imagestack" title="spexwavepy.imstackfun.Imagestack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Imagestack</span></code></a> classes.
They represent the loaded reference and sample image stacks, respectively.</p>
<p>After we invoke the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.collimate" title="spexwavepy.trackfun.Tracking.collimate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collimate()</span></code></a> method,
the two images from the reference and sample image stack are well aligned,
as shown in the following images.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/collima_after.png"><img alt="_images/collima_after.png" src="_images/collima_after.png" style="width: 80%;" /></a>
</figure>
<p>Please refer to the example <a class="reference internal" href="example.html#expplane"><span class="std std-ref">Plane mirror measurement with reference beam</span></a>
for the use of <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.collimate" title="spexwavepy.trackfun.Tracking.collimate"><code class="xref py py-func docutils literal notranslate"><span class="pre">collimate()</span></code></a> function
in real data processing procedure.</p>
</section>
<section id="xss-technique-with-reference-beam">
<span id="traxss"></span><h3>XSS technique with reference beam<a class="headerlink" href="#xss-technique-with-reference-beam" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer" title="spexwavepy.trackfun.Tracking.XSS_withrefer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer()</span></code></a> function
and <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer_multi" title="spexwavepy.trackfun.Tracking.XSS_withrefer_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_withrefer_multi()</span></code></a> function
are used to process the scanned data.
In this method, a reference image stack is needed.
Please refer to <a class="reference internal" href="principle.html#prinxssrefer"><span class="std std-ref">XSS technique with reference beam</span></a>
for the detailed description of the physics of this technique.</p>
<p>The important parameters of these two functions are <code class="docutils literal notranslate"><span class="pre">edge_x</span></code>, <code class="docutils literal notranslate"><span class="pre">edge_y</span></code>,
<code class="docutils literal notranslate"><span class="pre">edge_z</span></code>, <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code>, <code class="docutils literal notranslate"><span class="pre">pad_xy</span></code>. The last two parameters, <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code>
and <code class="docutils literal notranslate"><span class="pre">pad_xy</span></code> are only important in 2D case.</p>
<p><code class="docutils literal notranslate"><span class="pre">edge_x</span></code>, <code class="docutils literal notranslate"><span class="pre">edge_y</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_z</span></code> defines how the raw template images
are cut. If the scan is along ‘x’ direction, <code class="docutils literal notranslate"><span class="pre">scandim</span></code> = ‘x’, <code class="docutils literal notranslate"><span class="pre">edge_x</span></code>
is useless. Likewise, if scan is along ‘y’ direction, <code class="docutils literal notranslate"><span class="pre">scandim</span></code> = ‘y’,
<code class="docutils literal notranslate"><span class="pre">edge_y</span></code> is useless.</p>
<p>The diffuser was scanned along the y or x direction.
At each scan position, an image was taken.</p>
<p>For <strong>1D case</strong>, only a small strip of data from each raw image is extracted.
As a result, the whole image stack is cropped. This is done by setting <code class="docutils literal notranslate"><span class="pre">ROI</span></code>
for the image stacks.</p>
<figure class="align-default" id="id17">
<a class="reference internal image-reference" href="_images/XSSrefer_1.png"><img alt="_images/XSSrefer_1.png" src="_images/XSSrefer_1.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The cropped data strip for 1D data processing in y scan direction.</span><a class="headerlink" href="#id17" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id18">
<a class="reference internal image-reference" href="_images/XSSrefer_1x.png"><img alt="_images/XSSrefer_1x.png" src="_images/XSSrefer_1x.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The cropped data strip for 1D data processing in x scan direction.</span><a class="headerlink" href="#id18" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The XSS technique then process the data row(column) by row(column).
Each raw image in the image stack are taken at different diffuser position.
If we extract the <em>ith</em> row/column of every raw images and then stitch them together,
a new image is generated. Two images will be generated from both reference image stack
and the image stack with test optic.</p>
<figure class="align-default" id="id19">
<a class="reference internal image-reference" href="_images/XSSrefer_2.png"><img alt="_images/XSSrefer_2.png" src="_images/XSSrefer_2.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The stiched images for y scan data.</span><a class="headerlink" href="#id19" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id20">
<a class="reference internal image-reference" href="_images/XSSrefer_2x.png"><img alt="_images/XSSrefer_2x.png" src="_images/XSSrefer_2x.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The stiched images for x scan data.</span><a class="headerlink" href="#id20" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The newly generated two images are cross-correlated to track the speckle pattern shifts.
As mentioned in the above, <code class="docutils literal notranslate"><span class="pre">edge_x</span></code> is used for the y scan data. It is not used for
the x scan data. On the contrary, <code class="docutils literal notranslate"><span class="pre">edge_y</span></code> is used for the x scan data,
not used for the y scan data.
<code class="docutils literal notranslate"><span class="pre">edge_z</span></code> are used for both data set. <em>z</em> is the direction representing
the scan number.</p>
<figure class="align-default" id="id21">
<a class="reference internal image-reference" href="_images/XSSrefer_3.png"><img alt="_images/XSSrefer_3.png" src="_images/XSSrefer_3.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Stiched image for 1D data processing.</span><a class="headerlink" href="#id21" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Loop over each row in the raw image stack, a 1D speckle shift will be obtained.</p>
<p>For <strong>2D case</strong>, the similar 1D data processing procedure described in the above
will be looped over the horizontal or vertical direction.
For y scan direction, the outmost layer of the loop is along the x direction,
as shown in the following picture. The obtained speckle pattern shift is the
2D shift along the the y direction.</p>
<figure class="align-default" id="id22">
<a class="reference internal image-reference" href="_images/XSVT_refer2.png"><img alt="_images/XSVT_refer2.png" src="_images/XSVT_refer2.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The loop is over x direction when the scan is along y direction.</span><a class="headerlink" href="#id22" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Likewise, if the scan direction is x, the outmost loop of the 2D data processing
will be along the y direction. The obtained speckle pattern shift is in the 2D
shift along the x direction.</p>
<figure class="align-default" id="id23">
<a class="reference internal image-reference" href="_images/XSVT_refer3.png"><img alt="_images/XSVT_refer3.png" src="_images/XSVT_refer3.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The loop is over y direction when the scan is along x direction.</span><a class="headerlink" href="#id23" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>According to the above description, two more parameters play important roles.
As in the 1D case, <code class="docutils literal notranslate"><span class="pre">edge_x</span></code>, <code class="docutils literal notranslate"><span class="pre">edge_y</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_z</span></code> define how to
cut the raw images in the image stack. <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code> defines the width / height of
the subregion for the 2D data processing if the <code class="docutils literal notranslate"><span class="pre">scandim</span></code> is ‘y’ / ‘x’.
Each subregion is a strip of data resembles that in 1D case.
The subregion will move to cover the whole range of the raw images.
We use <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code> to define the width / height of the window, i.e.,
the stitched image, to be coross-correlated during each loop.
The reference stitched image should be larger than the template,
we use <code class="docutils literal notranslate"><span class="pre">pad_xy</span></code> to define how larger the reference stitched image is.
Apparently, <code class="docutils literal notranslate"><span class="pre">pad_xy[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">pad_xy[1]</span></code> should be smaller or equal to
<code class="docutils literal notranslate"><span class="pre">edge_x(edge_y)[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_x(edge_y)[1]</span></code>, respectively.
The larger the <code class="docutils literal notranslate"><span class="pre">pad_xy</span></code> is, the more trackable the image is, the slower the
tracking process can be.</p>
<figure class="align-default" id="id24">
<a class="reference internal image-reference" href="_images/XSSrefer_4.png"><img alt="_images/XSSrefer_4.png" src="_images/XSSrefer_4.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">2D image processing for y scan data.</span><a class="headerlink" href="#id24" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id25">
<a class="reference internal image-reference" href="_images/XSSrefer_4x.png"><img alt="_images/XSSrefer_4x.png" src="_images/XSSrefer_4x.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">2D image processing for x scan data.</span><a class="headerlink" href="#id25" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The remaing operations are the same as the 1D case described in the above.
Note that in order to do the integration, if <code class="docutils literal notranslate"><span class="pre">scandim</span></code> is <cite>‘xy’</cite>,
the 2D results in two directions will be cut to the same size automatically.</p>
<p>As been described in the <a class="reference internal" href="principle.html#prinxssrefer"><span class="std std-ref">XSS technique with reference beam</span></a>
section, after obtaining the speckle patter shifts, we can reconstruct the
slope of the wavefront from this techinque. Thus, the <code class="docutils literal notranslate"><span class="pre">sloX</span></code> and/or <code class="docutils literal notranslate"><span class="pre">sloY</span></code>
are stored in the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class according
to the scan direction. The related postprocess fucntions are
<a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_pixel" title="spexwavepy.postfun.slope_pixel"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_pixel()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_scan" title="spexwavepy.postfun.slope_scan"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_scan()</span></code></a>. Please refere to
<a class="reference internal" href="#slope"><span class="std std-ref">Slope reconstruction</span></a> in the
<a class="reference internal" href="#postfun"><span class="std std-ref">Post processing of the tracked speckle pattern shifts</span></a>
section for more information.</p>
</section>
<section id="self-reference-xss-technique">
<span id="traxssself"></span><h3>Self-reference XSS technique<a class="headerlink" href="#self-reference-xss-technique" title="Permalink to this heading"></a></h3>
<p>The <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self" title="spexwavepy.trackfun.Tracking.XSS_self"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self()</span></code></a> function
and <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_self_multi" title="spexwavepy.trackfun.Tracking.XSS_self_multi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XSS_self_multi()</span></code></a> function
are used for the <a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a>.
In terms of speckle pattern tracking, they are only a special case of
<a class="reference internal" href="#traxss"><span class="std std-ref">XSS technique with reference beam</span></a>. We only need to
be careful that for this technique, usually only one image stack is
provided.</p>
<p>Since it is a self-reference scheme, the template image stack and the
reference image stack are the same one. Slightly differ from
<a class="reference internal" href="#traxss"><span class="std std-ref">XSS technique with reference beam</span></a>, the generated
stiched images are from different (<em>i</em> th and <em>j</em> th) rows/columns
extracted from the same raw images in the stack.</p>
<a class="reference internal image-reference" href="_images/XSS_self.png"><img alt="_images/XSS_self.png" src="_images/XSS_self.png" style="width: 80%;" /></a>
<p>Apart from the newly introduced <code class="docutils literal notranslate"><span class="pre">nstep</span></code> parameter, all the other
parameters are the same as in the corresponding
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer" title="spexwavepy.trackfun.Tracking.XSS_withrefer"><code class="xref py py-func docutils literal notranslate"><span class="pre">XSS_withrefer()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSS_withrefer_multi" title="spexwavepy.trackfun.Tracking.XSS_withrefer_multi"><code class="xref py py-func docutils literal notranslate"><span class="pre">XSS_withrefer_multi()</span></code></a> functions,
as already been described in the above
<a class="reference internal" href="#traxss"><span class="std std-ref">XSS technique with reference beam</span></a>.</p>
<p>However, in the technique, the physical quantities directly reconstructed
from the tracked speckle pattern shifts are dfferent from the
<a class="reference internal" href="principle.html#prinxssrefer"><span class="std std-ref">XSS technique with reference beam</span></a>. The directly rconstructed
quantity in <a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a> is the
local curvature of the wavefront.</p>
<p>As a result, only <code class="docutils literal notranslate"><span class="pre">curvX</span></code> or <code class="docutils literal notranslate"><span class="pre">curvY</span></code> are stored in the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class. The related
postprocess fucntion is <a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.curv_scan" title="spexwavepy.postfun.curv_scan"><code class="xref py py-func docutils literal notranslate"><span class="pre">curv_scan()</span></code></a>.
Please refer to <a class="reference internal" href="#curvature"><span class="std std-ref">Local radius of curvature reconstruction</span></a>
section for details.</p>
</section>
<section id="xst-technique-with-reference-beam">
<span id="traxstrefer"></span><h3>XST technique with reference beam<a class="headerlink" href="#xst-technique-with-reference-beam" title="Permalink to this heading"></a></h3>
<p>Function <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_withrefer" title="spexwavepy.trackfun.Tracking.XST_withrefer"><code class="xref py py-func docutils literal notranslate"><span class="pre">XST_withrefer()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_withrefer_multi" title="spexwavepy.trackfun.Tracking.XST_withrefer_multi"><code class="xref py py-func docutils literal notranslate"><span class="pre">XST_withrefer_multi()</span></code></a> is used
for the XST technique with reference beam.</p>
<p>Unlike the scan-based techniques, XST techinque only requires two images.</p>
<p>For <strong>1D case</strong>, two modes are provided.
They are along <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> direction, respectively.
Like the scan-based techniques, a stripe of data along
the <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">x</span></code> direction is extracted. And again,
this is done by setting <code class="docutils literal notranslate"><span class="pre">ROI</span></code> for the image stacks.</p>
<figure class="align-default" id="id26">
<a class="reference internal image-reference" href="_images/XSTrefer_1.png"><img alt="_images/XSTrefer_1.png" src="_images/XSTrefer_1.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The cropped data strip for 1D data processing in y direction.</span><a class="headerlink" href="#id26" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id27">
<a class="reference internal image-reference" href="_images/XSTrefer_1x.png"><img alt="_images/XSTrefer_1x.png" src="_images/XSTrefer_1x.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The cropped data strip for 1D data processing in x direction.</span><a class="headerlink" href="#id27" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Compared to the XSS method, there are some more parameters needed
for this technique. Those parameters are <code class="docutils literal notranslate"><span class="pre">edge_x</span></code>, <code class="docutils literal notranslate"><span class="pre">edge_y</span></code>,
<code class="docutils literal notranslate"><span class="pre">hw_xy</span></code>, <code class="docutils literal notranslate"><span class="pre">pad_x</span></code> and <code class="docutils literal notranslate"><span class="pre">pad_y</span></code>.</p>
<figure class="align-default" id="id28">
<a class="reference internal image-reference" href="_images/XSTrefer_2.png"><img alt="_images/XSTrefer_2.png" src="_images/XSTrefer_2.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Parameters for 1D data processing in y direction</span><a class="headerlink" href="#id28" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id29">
<a class="reference internal image-reference" href="_images/XSTrefer_2x.png"><img alt="_images/XSTrefer_2x.png" src="_images/XSTrefer_2x.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Parameters for 1D data processing in x direction</span><a class="headerlink" href="#id29" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p><code class="docutils literal notranslate"><span class="pre">edge_x</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_y</span></code> define the area to be cut from the template
in order to be able to do the cross-correlation. Unlike the XSS technique,
we need <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code> to generate the subregion from the template for
cross-correlation. If the <code class="docutils literal notranslate"><span class="pre">scandim</span></code> is ‘x’, then <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code> is the
width you want to choose to generate the subregion, also in this case,
<code class="docutils literal notranslate"><span class="pre">pad_y</span></code> is useless ; if the <code class="docutils literal notranslate"><span class="pre">scandim</span></code> is ‘y’, <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code> is the
height you want to choose for your subregion, <code class="docutils literal notranslate"><span class="pre">pad_x</span></code> is
useless in this case.</p>
<p>For <strong>2D case</strong>, there are several more parameters needed apart from
those in the 1D case. Also, some parameters are slightly different
compared to the 1D case.</p>
<figure class="align-default" id="id30">
<a class="reference internal image-reference" href="_images/XSTrefer_3.png"><img alt="_images/XSTrefer_3.png" src="_images/XSTrefer_3.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Parameters for 2D data processing in y direction</span><a class="headerlink" href="#id30" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id31">
<a class="reference internal image-reference" href="_images/XSTrefer_3x.png"><img alt="_images/XSTrefer_3x.png" src="_images/XSTrefer_3x.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">Parameters for 2D data processing in x direction</span><a class="headerlink" href="#id31" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>As shown in the above images, <code class="docutils literal notranslate"><span class="pre">edge_x</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_y</span></code> define the
cutting areas for the raw template image. Then <code class="docutils literal notranslate"><span class="pre">window</span></code> and <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code>
define the real size of the subregion used for tracking.
If the <code class="docutils literal notranslate"><span class="pre">scandim</span></code> is ‘y’, <code class="docutils literal notranslate"><span class="pre">window</span></code> is the width of the subregion,
<code class="docutils literal notranslate"><span class="pre">hw_xy</span></code> is the height of it; if <code class="docutils literal notranslate"><span class="pre">scandim</span></code> is ‘x’, <code class="docutils literal notranslate"><span class="pre">window</span></code> is the
height of the subregion and <code class="docutils literal notranslate"><span class="pre">hw_xy</span></code> is the width of it.
<code class="docutils literal notranslate"><span class="pre">pad_x</span></code> and <code class="docutils literal notranslate"><span class="pre">pad_y</span></code> determines the extra area for tracking.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">scandim</span></code> is ‘xy’, then <code class="docutils literal notranslate"><span class="pre">edge_x</span></code> and <code class="docutils literal notranslate"><span class="pre">edge_y</span></code> should be the same, as well as the elements within them.
So is the <code class="docutils literal notranslate"><span class="pre">pad_x</span></code> and <code class="docutils literal notranslate"><span class="pre">pad_y</span></code>.</p>
</div>
<p>Since this technique has a reference, after we obtain the speckle pattern shifts,
we can calculate the <code class="docutils literal notranslate"><span class="pre">sloX</span></code> and/or <code class="docutils literal notranslate"><span class="pre">sloY</span></code>. These are stored in the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class. The slopes are calculated using
<a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_pixel" title="spexwavepy.postfun.slope_pixel"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_pixel()</span></code></a> function. See <a class="reference internal" href="#slope"><span class="std std-ref">Slope reconstruction</span></a>
for more details.</p>
</section>
<section id="self-reference-xst-technique">
<span id="traxstself"></span><h3>Self-reference XST technique<a class="headerlink" href="#self-reference-xst-technique" title="Permalink to this heading"></a></h3>
<p><a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self" title="spexwavepy.trackfun.Tracking.XST_self"><code class="xref py py-func docutils literal notranslate"><span class="pre">XST_self()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self_multi" title="spexwavepy.trackfun.Tracking.XST_self_multi"><code class="xref py py-func docutils literal notranslate"><span class="pre">XST_self_multi()</span></code></a> are the
two functions used for the data processing of the
<a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>. Unlike the
<a class="reference internal" href="#traxssself"><span class="std std-ref">self-reference XSS technqiue</span></a>, we still need
two image stacks here. Each image stack has only one image. Since
no reference beam is available, the reference and template images
are both that with tested optic in the beam, only at two different
diffuser positions.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/XSTselfcode.png"><img alt="_images/XSTselfcode.png" src="_images/XSTselfcode.png" style="width: 80%;" /></a>
</figure>
<p>After defining the necessary two image stacks, all the other parameters
for <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self" title="spexwavepy.trackfun.Tracking.XST_self"><code class="xref py py-func docutils literal notranslate"><span class="pre">XST_self()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XST_self_multi" title="spexwavepy.trackfun.Tracking.XST_self_multi"><code class="xref py py-func docutils literal notranslate"><span class="pre">XST_self_multi()</span></code></a> are the same as
the <a class="reference internal" href="#traxstrefer"><span class="std std-ref">XST technique with reference beam</span></a> and have
been described there.</p>
<p>However, unlike the <a class="reference internal" href="principle.html#prinxstrefer"><span class="std std-ref">XST technique with reference beam</span></a>,
the physical quantities directly reconstructed
from the tracked speckle pattern shifts are local curvature of the wavefront.
They are stored in the parameters <code class="docutils literal notranslate"><span class="pre">curvX</span></code> and/or <code class="docutils literal notranslate"><span class="pre">curvY</span></code> in the
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a> class. The related
postprocess fucntion is <a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.curv_pixel" title="spexwavepy.postfun.curv_pixel"><code class="xref py py-func docutils literal notranslate"><span class="pre">curv_pixel()</span></code></a>.
Please refer to <a class="reference internal" href="#curvature"><span class="std std-ref">Local radius of curvature reconstruction</span></a>
section for details.</p>
</section>
<section id="xsvt-technique">
<span id="traxsvtrefer"></span><h3>XSVT technique<a class="headerlink" href="#xsvt-technique" title="Permalink to this heading"></a></h3>
<p><a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSVT_withrefer" title="spexwavepy.trackfun.Tracking.XSVT_withrefer"><code class="xref py py-func docutils literal notranslate"><span class="pre">XSVT_withrefer()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking.XSVT_withrefer_multi" title="spexwavepy.trackfun.Tracking.XSVT_withrefer_multi"><code class="xref py py-func docutils literal notranslate"><span class="pre">XSVT_withrefer_multi()</span></code></a> are the
two functions used for the data processing of the
<a class="reference internal" href="principle.html#prinxsvtrefer"><span class="std std-ref">XSVT technique</span></a>. Since this type of technique needs
images of the reference beam and the beam with tested optics, so we need
two image stacks. Each image in the image stacks are taken at one random
scan position of the diffuser during the movement. As a result, the
<code class="docutils literal notranslate"><span class="pre">scandim</span></code> is set to be ‘random’, the <code class="docutils literal notranslate"><span class="pre">scanstep</span></code> is useless.</p>
<p>Like the XSS-type techniques, the raw image stack is a 3D data set.
Unlike the XSS-type techniques, the scan step in this technique has
no clear physical meaning. It has no use in the data processing. Also,
the ‘1D’ mode is not supported in this technique. The data processing
mode in this technique is assumed to be two-dimentional.</p>
<p>The important parameters of these two functions are <code class="docutils literal notranslate"><span class="pre">edge_xy</span></code>, <code class="docutils literal notranslate"><span class="pre">edge_z</span></code>,
<code class="docutils literal notranslate"><span class="pre">hw_xy</span></code>, <code class="docutils literal notranslate"><span class="pre">pad_xy</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">hw_xy</span></code> defines the window size of the subregion to be processed
on the raw image. As shown in the picture below. Note the selected area
is a square.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/XSVT_refer1.png"><img alt="_images/XSVT_refer1.png" src="_images/XSVT_refer1.png" style="width: 80%;" /></a>
</figure>
<p>Like the XSS-type techniques, the XSVT technique will process the data
row by row and column by column to obtain the displacements in two
dimensions. Unlike the XSS-type techniques, since there is no clear
physcial meaning in the scan direction, we obtain the speckle pattern
shifts in x direction from the row-by-row data processing and y direction
from the column-by-column data processing. As a result, the obtained
shifts are in the unit of the pixels size rather than the scan step
as in the XSS-type techniques.</p>
<p>Due to the above reasons, for the practical implementation of the
XSVT technique, we do the speckle tracking data processing two times
to obtain the shifts in x and y direction, respectively. The data
processing procedure resembles the 2D case XSS technique
with reference beam.</p>
<p>To obtain the speckle pattern shift in the x direction, the outmost
loop is along the same direction.</p>
<figure class="align-default" id="id32">
<a class="reference internal image-reference" href="_images/XSVT_refer2.png"><img alt="_images/XSVT_refer2.png" src="_images/XSVT_refer2.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The loop is over x direction to obtain the speckle pattern shift in this direction.</span><a class="headerlink" href="#id32" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Likewise, the outmost loop is along y direction if the speckle pattern
shift in y direction is to be tracked.</p>
<figure class="align-default" id="id33">
<a class="reference internal image-reference" href="_images/XSVT_refer3.png"><img alt="_images/XSVT_refer3.png" src="_images/XSVT_refer3.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-text">The loop is over y direction to obtain the speckle pattern shift in this direction.</span><a class="headerlink" href="#id33" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Note to distinguish the above data processing procedure with the
XSS-type techniques. Although the implementation of the codes are
almost the same, the way to obtain the speckle pattern shifts for
these two techniques are different. The shifts obtained from XSVT
technique are in the unit of pixel size. Unlike it, the shifts
obtained from the XSS-type techniques are in the unit of scan step.</p>
</section>
</section>
<section id="post-processing-of-the-tracked-speckle-pattern-shifts">
<span id="postfun"></span><h2>Post processing of the tracked speckle pattern shifts<a class="headerlink" href="#post-processing-of-the-tracked-speckle-pattern-shifts" title="Permalink to this heading"></a></h2>
<section id="d-integration-for-post-processing">
<span id="use2dint"></span><h3>2D integration for post processing<a class="headerlink" href="#d-integration-for-post-processing" title="Permalink to this heading"></a></h3>
<p><em>Say something here for 2D integration…</em></p>
</section>
<section id="slope-reconstruction">
<span id="slope"></span><h3>Slope reconstruction<a class="headerlink" href="#slope-reconstruction" title="Permalink to this heading"></a></h3>
<p>Two functions are provided in the package, the are
<a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_scan" title="spexwavepy.postfun.slope_scan"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_scan()</span></code></a> and
<a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_pixel" title="spexwavepy.postfun.slope_pixel"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_pixel()</span></code></a>, respectively.
These two functions are called depending on the unit of the
tracked shifts.</p>
<p>Usually, for the XSS (both <a class="reference internal" href="principle.html#prinxssrefer"><span class="std std-ref">with reference beam</span></a> or
<a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference</span></a>), the tracked
shifts are in the unit of scan step in the scan direction, thus, the
<a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_scan" title="spexwavepy.postfun.slope_scan"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_scan()</span></code></a> function is called. If the tracked
shifts are in the unit of pixel size, such as other tracking methods, then the
<a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_pixel" title="spexwavepy.postfun.slope_pixel"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_pixel()</span></code></a> function is called.</p>
<p>If we use <span class="math notranslate nohighlight">\(\mu\)</span> to represent the tracked shifts regardless of its unit,
<span class="math notranslate nohighlight">\(p\)</span> the detector pixel size, <span class="math notranslate nohighlight">\(s\)</span> the scan step size, <span class="math notranslate nohighlight">\(d\)</span>
the distacne betweeen the diffuser and the detector, for
<a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_scan" title="spexwavepy.postfun.slope_scan"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_scan()</span></code></a> function, we have:</p>
<div class="math notranslate nohighlight">
\[slope = \frac{\mu \times s}{d}\]</div>
<p>for <a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.slope_pixel" title="spexwavepy.postfun.slope_pixel"><code class="xref py py-func docutils literal notranslate"><span class="pre">slope_pixel()</span></code></a> function, we have:</p>
<div class="math notranslate nohighlight">
\[slope = \frac{\mu \times p}{d}\]</div>
</section>
<section id="local-curvature-reconstruction">
<span id="curvature"></span><h3>Local curvature reconstruction<a class="headerlink" href="#local-curvature-reconstruction" title="Permalink to this heading"></a></h3>
<p>Usually, the local radius of curvature is reconstructed from the
<a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a> and
<a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a> techniques.
There are two geometric relations used to calculate the local
radius of curvature depending on where the diffuser is placed. This information
is stored in the <code class="docutils literal notranslate"><span class="pre">mempos</span></code> attribute of the <a class="reference internal" href="spexwavepy.html#spexwavepy.trackfun.Tracking" title="spexwavepy.trackfun.Tracking"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tracking</span></code></a>
class. The <a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.curv_scan" title="spexwavepy.postfun.curv_scan"><code class="xref py py-func docutils literal notranslate"><span class="pre">curv_scan()</span></code></a> function is used for
the XSS technique, the <a class="reference internal" href="spexwavepy.html#spexwavepy.postfun.curv_pixel" title="spexwavepy.postfun.curv_pixel"><code class="xref py py-func docutils literal notranslate"><span class="pre">curv_pixel()</span></code></a> function
is used for the XST technique.
They both return the local
curvature of the wavefront <strong>at the detector plane</strong>. It is easy to convert this
to the wavefront curvature at the diffuser plane.</p>
<p>We show the downstream case at first.</p>
<a class="reference internal image-reference" href="_images/downstream.jpg"><img alt="_images/downstream.jpg" src="_images/downstream.jpg" style="width: 80%;" /></a>
<p>In downstream case, the diffuser is placed in the downstream of the focus of the
tested optic if it has one. If we use <span class="math notranslate nohighlight">\(p\)</span> to represent the detector pixel
size, <span class="math notranslate nohighlight">\(\mu\)</span> the tracked shift, <span class="math notranslate nohighlight">\(s\)</span> the scan step size, <span class="math notranslate nohighlight">\(j-i\)</span> the
spacing of the columns/rows to be extracted and stiched, <span class="math notranslate nohighlight">\(d\)</span> the distacne
betweeen the diffuser and the detector, <span class="math notranslate nohighlight">\(m\)</span> the magnification
factor, then we have the following equation.</p>
<p>For <a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a>:</p>
<div class="math notranslate nohighlight">
\[m = \frac{\mu \times s}{(j-i) \times p} = \frac{R-d}{R}\]</div>
<p>For <a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>:</p>
<div class="math notranslate nohighlight">
\[m = \frac{s}{\mu \times p} = \frac{R-d}{R}\]</div>
<p>The local curvature of the wavefront at the detector plane is <span class="math notranslate nohighlight">\(1/R\)</span>, thus we
have:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{R} = \frac{1-m}{d}\]</div>
<p>Now let’s look at the upstream case.</p>
<a class="reference internal image-reference" href="_images/upstream.jpg"><img alt="_images/upstream.jpg" src="_images/upstream.jpg" style="width: 80%;" /></a>
<p>We use the same symbols to represent the related physical quantity. For the upstream case,
the distance betweeen the diffuser and the detector <span class="math notranslate nohighlight">\(d\)</span> is assumed to be <strong>the centre
of the tested optic and the detector</strong>, since we assume the incident beam has negligible
divergence and the beam is modulated only after the optic.</p>
<p>The equation to describe the geometric relation is slightly different from the downstream
case.</p>
<p>For <a class="reference internal" href="principle.html#prinxssself"><span class="std std-ref">self-reference XSS technique</span></a>:</p>
<div class="math notranslate nohighlight">
\[m = \frac{\mu \times s}{(j-i) \times p} = \frac{d-R}{R}\]</div>
<p>For <a class="reference internal" href="principle.html#prinxstself"><span class="std std-ref">self-reference XST technique</span></a>:</p>
<div class="math notranslate nohighlight">
\[m = \frac{s}{\mu \times p} = \frac{d-R}{R}\]</div>
<p>The local curvature of the wavefront at the detector plane is:</p>
<div class="math notranslate nohighlight">
\[\frac{1}{R} = \frac{1+m}{d}\]</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Apart from the above two cases, there are other geometric situations. However,
these other situations can be equivalent to the the above two cases, only need
to note that the obtained curvature may no longer at the detector plane, it may
at the diffuser plane instead. For plane mirror, set <code class="docutils literal notranslate"><span class="pre">mempos</span></code> to downstream
is usually better since its focus is always very far.</p>
</div>
</section>
<section id="d-integration-from-the-slope">
<span id="integral"></span><h3>2D integration from the slope<a class="headerlink" href="#d-integration-from-the-slope" title="Permalink to this heading"></a></h3>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="example.html" class="btn btn-neutral float-left" title="Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api.html" class="btn btn-neutral float-right" title="API reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Lingfei Hu, Hongchang Wang.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>